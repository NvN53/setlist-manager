<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
    <title>SetDesk</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#007bff">
    <link rel="apple-touch-icon" href="assets/icon-192.svg">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="styles.css">


        






<body>
    <div class="app">
        <!-- Home Page - Songs -->
        <div id="home-songs-page">
            <div class="home-header-fixed">
                <div class="header">
                    <h1>SetDesk <span class="version-text" style="font-size: 0.7em; color: #6c757d; font-weight: normal;">v1.5</span></h1>
                    <div class="menu-container">
                        <i class="fas fa-ellipsis-v menu-icon"></i>
                        <div class="dropdown-menu hidden">
                            <div class="menu-item" id="settings-menu-item">Settings</div>
                            <div class="menu-item" id="account-menu-item-songs">Account</div>
                        </div>
                    </div>
                </div>
                <div class="search-box-container">
                    <input type="text" placeholder="Search" class="search-box" id="song-search">
                    <button class="clear-search-btn hidden" id="clear-song-search">A-</button>
                </div>
                <div class="tabs">
                    <div class="tab active" id="songs-tab">SONGS</div>
                    <div class="tab" id="setlists-tab">SETLISTS</div>
                </div>
            </div>
            <div class="home-content-scrollable">
                <div id="songs-list"></div>
            </div>
            <button class="floating-button" id="add-song-btn">+</button>
        </div>

        <!-- Home Page - Setlists -->
        <div id="home-setlists-page" class="hidden">
            <div class="home-header-fixed">
                <div class="header">
                    <h1>SetDesk <span class="version-text" style="font-size: 0.7em; color: #6c757d; font-weight: normal;">v1.5</span></h1>
                    <div class="menu-container">
                        <i class="fas fa-ellipsis-v menu-icon"></i>
                        <div class="dropdown-menu hidden">
                            <div class="menu-item" id="settings-menu-item-2">Settings</div>
                            <div class="menu-item" id="account-menu-item-setlists">Account</div>
                        </div>
                    </div>
                </div>
                <div class="search-box-container">
                    <input type="text" placeholder="Search" class="search-box" id="setlist-search">
                    <button class="clear-search-btn hidden" id="clear-setlist-search">A-</button>
                </div>
                <div class="tabs">
                    <div class="tab" id="back-to-songs-tab">SONGS</div>
                    <div class="tab active" id="setlists-tab-active">SETLISTS</div>
                </div>
            </div>
            <div class="home-content-scrollable">
                <div id="setlists-list"></div>
            </div>
            <button class="floating-button" id="add-setlist-btn">+</button>
        </div>

        <!-- View Setlist Page -->
        <div id="view-setlist-page" class="hidden">
            <div class="page-header">
                <button class="btn btn-secondary" id="back-to-setlists-from-view"><i class="fas fa-arrow-left"></i></button>
                <h2 id="view-setlist-title">Setlist Title</h2>
                <div class="menu-container">
                    <i class="fas fa-ellipsis-v menu-icon"></i>
                    <div class="dropdown-menu hidden">
                        <div class="menu-item" id="edit-setlist-menu-item">Edit Setlist</div>
                    </div>
                </div>
            </div>

            <div id="view-setlist-songs-container">
                <!-- Songs in setlist will be dynamically added here -->
            </div>
        </div>

        <!-- Edit Setlist Page -->
        <div id="edit-setlist-page" class="hidden">
            <div class="page-header">
                <button class="btn btn-secondary" id="cancel-edit-setlist-btn"><i class="fas fa-arrow-left"></i></button>
                <h2 id="edit-setlist-title">Edit Setlist</h2>
                <button class="btn btn-primary" id="save-setlist-btn">Save</button>
            </div>

            <div class="form-group">
                <label>Setlist Title</label>
                <input type="text" id="setlist-title" placeholder="Setlist title">
            </div>

            <div class="form-group">
                <label>Songs in Setlist</label>
                <div id="setlist-songs-container">
                    <!-- Songs will be dynamically added here -->
                </div>
            </div>

            <div class="form-group">
                <label>Add Songs</label>
                <div class="search-box-container">
                    <input type="text" placeholder="Search songs" class="search-box" id="add-song-search">
                    <button class="clear-search-btn hidden" id="clear-add-song-search">A-</button>
                </div>
                <div id="available-songs-list">
                    <!-- Available songs will be listed here -->
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-danger" id="delete-setlist-btn">Delete Setlist</button>
            </div>
        </div>

        <!-- Edit Song Page -->
        <div id="edit-song-page" class="hidden">
            <div class="page-header">
                <button class="btn btn-secondary" id="cancel-edit-btn"><i class="fas fa-arrow-left"></i></button>
                <h2>Edit Song</h2>
                <button class="btn btn-primary" id="save-song-btn">Save</button>
            </div>

            <div class="form-group">
                <label>Title</label>
                <input type="text" id="song-title" placeholder="Song title">
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label>Key</label>
                    <select id="song-key">
                        <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option><option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option><option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Mode</label>
                    <select id="song-mode">
                        <option value="major">Major</option>
                        <option value="minor">Minor</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>BPM</label>
                    <input type="number" id="song-bpm" min="20" max="300" value="120">
                </div>
                <div class="form-group">
                    <label>Time Sig</label>
                    <select id="song-time-sig">
                        <option value="2/4">2/4</option><option value="3/4">3/4</option><option value="4/4" selected>4/4</option><option value="6/8">6/8</option>
                    </select>
                </div>
            </div>

            <div class="form-group">
                <label>Lyrics & Chords</label>
                <textarea class="textarea-lyrics" id="song-lyrics" placeholder="Enter lyrics and chords here..."></textarea>
            </div>

            <div class="action-buttons">
                <button class="btn btn-danger" id="delete-song-btn">Delete Song</button>
                <button class="btn btn-secondary" id="duplicate-song-btn">Duplicate Song</button>
            </div>
        </div>

        <!-- Lyrics Page -->
        <div id="lyrics-page" class="hidden">
            <div class="home-header-fixed">
                <div class="page-header">
                    <button class="btn btn-secondary" id="back-to-songs-from-lyrics"><i class="fas fa-arrow-left"></i></button>
                    <h2 id="lyrics-title">Song Title</h2>
                    <div class="menu-container">
                        <i class="fas fa-ellipsis-v menu-icon"></i>
                        <div class="dropdown-menu hidden">
                            <div class="menu-item" id="edit-song-menu-item">Edit Song</div>
                            <div class="menu-item" id="delete-song-menu-item">Delete Song</div>
                        </div>
                    </div>
                </div>

                <div class="navigation-buttons" style="display: flex; justify-content: space-between; margin: 5px 0;">
                    <button class="btn btn-secondary" id="prev-song-btn" style="display: none;"><i class="fas fa-arrow-left"></i> Previous</button>
                    <button class="btn btn-secondary" id="next-song-btn" style="display: none;">Next <i class="fas fa-arrow-right"></i></button>
                </div>

                <div class="song-details" id="lyrics-details" style="margin: 5px 0;">Key � BPM bpm</div>

                <div class="controls">
                    <div class="main-controls" style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                        <div class="ambient-btn-container">
                                                <button class="btn btn-secondary ambient-toggle" id="ambient-toggle" style="font-size: 0.8rem; padding: 5px 10px; border-radius: 4px 0 0 4px; border-right: none;">
                                                    Ambient
                                                </button>
                                                <button class="btn btn-secondary ambient-dropdown" id="ambient-dropdown" style="font-size: 0.8rem; padding: 5px 5px; border-radius: 0 4px 4px 0; margin-left: -1px;">
                                                    <i class="fas fa-chevron-down"></i>
                                                </button>
                                            </div>
                        <button id="metronome-toggle" class="btn btn-secondary" style="font-size: 0.8rem; padding: 5px 10px; display: flex; align-items: center; justify-content: center;">Metronome</button>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <label style="font-size: 0.8rem; margin: 0;">Autoscroll:</label>
                            <button id="autoscroll-toggle" class="btn btn-secondary" style="font-size: 0.8rem; padding: 3px 8px; min-width: 40px;">Off</button>
                            <select id="autoscroll-level" style="font-size: 0.8rem; padding: 3px;" disabled>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                    </div>
                    <div class="transpose-controls" style="display: flex; justify-content: center; gap: 10px; margin-bottom: 5px;">
                        <button class="btn btn-secondary" id="transpose-down-lyrics" style="width: 30px; height: 30px; font-size: 0.8rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; padding: 0;">-</button>
                        <span class="transpose-value" id="transpose-value">0</span>
                        <button class="btn btn-secondary" id="transpose-up-lyrics" style="width: 30px; height: 30px; font-size: 0.8rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; padding: 0;">+</button>
                    </div>
                </div>
            </div>

            <div class="home-content-scrollable">
                <div class="lyrics-container" id="lyrics-content"></div>
            </div>
        </div>

        <!-- Settings Page -->
        <div id="settings-page" class="hidden">
            <div class="app">
                <div class="page-header">
                    <button class="btn btn-secondary" id="back-to-home-from-settings"><i class="fas fa-arrow-left"></i></button>
                    <h2>Settings</h2>
                    <div></div> <!-- Spacer for flex alignment -->
                </div>

                <div class="form-group">
                    <label>Appearance</label>
                    <div class="setting-item">
                        <span>Dark Mode</span>
                        <label class="switch">
                            <input type="checkbox" id="dark-mode-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <label>Metronome Volume</label>
                    <input type="range" min="0" max="100" value="50" class="volume-slider" id="metronome-volume">
                    <div class="volume-label">Volume: <span id="metronome-volume-value">50</span>%</div>
                </div>
            </div>
        </div>
        
        <!-- Account Page -->
        <div id="auth-page" class="hidden">
            <div class="home-header-fixed">
                <div class="header">
                    <button class="btn btn-secondary" id="back-to-songs-from-auth"><i class="fas fa-arrow-left"></i></button>
                    <h2>Account</h2>
                    <div class="menu-container">
                        <i class="fas fa-ellipsis-v menu-icon"></i>
                        <div class="dropdown-menu hidden">
                            <div class="menu-item" id="auth-menu-item">Sign Out</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="home-content-scrollable">
                <div class="auth-container" style="padding: 20px;">
                    <h2>Account</h2>
                    <div id="auth-content">
                        <div id="login-form">
                            <input id="email" type="email" placeholder="Email" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px;" />
                            <input id="password" type="password" placeholder="Password" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px;" />
                            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                <button id="signup" class="btn btn-primary" style="flex: 1; padding: 10px;">Sign Up</button>
                                <button id="login" class="btn btn-secondary" style="flex: 1; padding: 10px;">Log In</button>
                            </div>
                            <button id="logout" class="btn btn-outline-danger" style="width: 100%; padding: 10px; display: none;">Log Out</button>
                        </div>
                        <pre id="status" style="background: #f5f5f5; padding: 10px; border-radius: 4px; margin-top: 10px; white-space: pre-wrap; display: none;"></pre>
                        <div id="user-info" style="margin-top: 15px; padding: 10px; background: #f0f8ff; border-radius: 4px; display: none;">
                            <strong>Logged in as:</strong> <span id="user-email"></span>
                            <div style="margin-top: 10px;">
                                <button id="auth-logout" class="btn btn-outline-danger" style="width: 100%; padding: 8px;">Logout</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Ambient Pad Modal -->
        <div id="ambient-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <div class="page-header">
                    <h2>Ambient Pad</h2>
                    <button class="close-btn" id="close-ambient-modal"><i class="fas fa-times"></i></button>
                </div>

                <div class="form-group">
                    <label>Ambient Pad</label>
                    <div class="pad-status" id="pad-status">Inactive</div>
                </div>

                <div class="form-group">
                    <label>Mode</label>
                    <div class="mode-selection">
                        <div class="mode-option">
                            <button class="btn pitch-btn" data-mode="major">Major</button>
                        </div>
                        <div class="mode-option">
                            <button class="btn pitch-btn" data-mode="minor">Minor</button>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Pitch</label>
                    <div id="pitch-buttons"></div>
                </div>

                <div class="form-group">
                    <label>Volume</label>
                    <input type="range" min="0" max="100" value="50" class="volume-slider" id="volume-slider">
                </div>
                
                <div class="form-group">
                    <label>Pitch Detection</label>
                    <button id="tap-to-hum" class="btn btn-secondary" style="width: 100%; padding: 12px; margin-bottom: 10px;">Tap to Hum</button>
                    <div class="pitch-hint" style="text-align: center; font-size: 0.8em; color: #6c757d; margin-bottom: 10px;">
                        <div>Hum a steady note (no vibrato)</div>
                        <div>Use 'mmm' sound</div>
                    </div>
                    <div id="detected-pitch" class="pad-status" style="text-align: center; min-height: 24px; font-weight: bold;">
                        <span id="detected-pitch-value">-</span>
                    </div>
                    <button id="use-detected-pitch" class="btn btn-outline-primary" style="width: 100%; margin-top: 10px; display: none;">Use Detected Pitch</button>
                </div>
            </div>
        </div>
    </div>

<script>
/* ---------- data & startup (unchanged) ---------- */
let songs = [];

// Load songs from Supabase database
async function loadSongsFromDatabase() {
    console.log('Loading songs from database...');
    try {
        if (window.db) {
            // Fetch all songs from the database
            const { data, error } = await window.db
                .from('songs')
                .select('*')
                .order('created_at', { ascending: false });
            
            if (error) {
                console.error('Error fetching songs:', error);
                // If there's an error, set to empty array
                songs = [];
            } else {
                console.log('Fetched songs data:', data);
                // Map Supabase data to local format
                songs = data.map(song => ({
                    id: song.id,
                    title: song.title,
                    key: song.key || '',
                    bpm: song.bpm || 120,  // Default to 120 if not provided
                    timeSig: '', // timeSig not in DB, so set to empty
                    lyrics: song.lyrics || '',
                    user_id: song.user_id  // Include user_id for ownership checks
                }));
                console.log('Mapped songs array:', songs);
            }
        } else {
            // If no db available, set to empty array
            songs = [];
            console.error('Database not available');
        }
    } catch (error) {
        console.error('Error loading songs:', error);
        songs = [];
    }
    
    console.log('Final songs array:', songs);
    // Re-render the song list after loading
    renderSongsList();
}

// Load setlists from Supabase database
async function loadSetlistsFromDatabase() {
    console.log('Loading setlists from database...');
    try {
        if (window.db) {
            // Fetch all setlists from the database
            const { data, error } = await window.db
                .from('setlists')
                .select('*')
                .order('created_at', { ascending: false });
            
            if (error) {
                console.error('Error fetching setlists:', error);
                // If there's an error, set to empty array
                setlists = [];
            } else {
                console.log('Fetched setlists data:', data);
                // Map Supabase data to local format
                setlists = data.map(setlist => ({
                    id: setlist.id,
                    title: setlist.title,
                    user_id: setlist.user_id  // Include user_id for ownership checks
                }));
                
                // Now fetch the songs for each setlist
                for (let i = 0; i < setlists.length; i++) {
                    const setlistId = setlists[i].id;
                    const { data: setlistSongsData, error: setlistSongsError } = await window.db
                        .from('setlist_songs')
                        .select('song_id, position')
                        .eq('setlist_id', setlistId)
                        .order('position', { ascending: true });
                    
                    if (setlistSongsError) {
                        console.error('Error fetching setlist songs:', setlistSongsError);
                        setlists[i].songIds = [];
                    } else {
                        setlists[i].songIds = setlistSongsData.map(ss => ss.song_id);
                    }
                }
                console.log('Loaded setlists:', setlists);
            }
        } else {
            // If no db available, set to empty array
            setlists = [];
            console.error('Database not available for setlists');
        }
    } catch (error) {
        console.error('Error loading setlists:', error);
        setlists = [];
    }
    
    // Re-render the setlist list after loading
    renderSetlistsList();
}

// Load user preferences from Supabase
async function loadUserPreferences() {
    // This function can be expanded to load user-specific preferences
    // like transpose, bpm override, autoscroll speed, etc.
    try {
        if (window.db) {
            const { data: { user }, error: userError } = await window.db.auth.getUser();
            if (!userError && user) {
                // User is logged in, load user-specific preferences if needed
                console.log('User preferences can be loaded here');
            }
        }
    } catch (error) {
        console.error('Error loading user preferences:', error);
    }
}

// Old songs data - keeping for reference
let oldSongs = JSON.parse(localStorage.getItem('setlistManager_songs')) || [
    { id: 1, title: 'Amazing Grace', key: 'G', bpm: 78, timeSig: '4/4', lyrics: 'G\nAmazing grace, how sweet the sound\nG           C\nThat saved a wretch like me\nG               Em\nI once was lost, but now am found\nG       D          G\nWas blind, but now I see' },
    { id: 2, title: 'Hallelujah', key: 'C', bpm: 68, timeSig: '4/4', lyrics: 'C                    Am\nI\'ve heard there was a secret chord\nF                      C\nThat David played and it pleased the Lord\nG                      Em\nBut you don\'t really care for music, do ya?\nF           C          G\nIt goes like this the fourth, the fifth\nAm                 F\nThe minor fall, the major lift\nG              Em         Am\nThe baffled king composing Hallelujah' },
    { id: 3, title: 'Ente Daivame', key: 'Fm', bpm: 92, timeSig: '4/4', lyrics: 'Fm              C\nEnte daivame nee thanne\nFm              C\nEnte sakhavum nee thanne\nDm              Fm\nEnte snehithanum nee thanne\nC               Fm\nEnikku vendiyavanum nee thanne' }
];
let setlists = JSON.parse(localStorage.getItem('setlistManager_setlists')) || [
    { id: 1, title: 'Sunday Service �?" Jan 12', songIds: [1, 2] },
    { id: 2, title: 'Christmas Eve Mass', songIds: [2, 3] },
    { id: 3, title: 'Malayalam Choir Practice', songIds: [3, 1] }
];

// Load metronome sound
function loadMetronomeSound() {
    const request = new XMLHttpRequest();
    request.open('GET', 'assets/audio/metronome.wav', true);
    request.responseType = 'arraybuffer';
    
    request.onload = function() {
        if (!audioContext) {
            console.warn('Audio context not available yet');
            return;
        }
        
        audioContext.decodeAudioData(request.response, function(buffer) {
            metronomeBuffer = buffer;
        }, function(error) {
            console.error('Error decoding metronome sound:', error);
        });
    };
    
    request.onerror = function() {
        console.error('Error loading metronome sound');
    };
    
    request.send();
}

// Create audio context and load metronome sound on first user interaction
let audioContextCreated = false;
document.body.addEventListener('click', function initAudio() {
    if (!audioContextCreated) {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            loadMetronomeSound();
            audioContextCreated = true;
        } catch (e) {
            console.error('Web Audio API is not supported in this browser', e);
        }
    }
}, { once: true });

// Initialize ambient pad when audio context is available
function initAmbientPad() {
    if (!audioContext) {
        console.warn('Audio context not available yet');
        return null;
    }
    
    return {
        oscillators: [],
        gainNode: null,
        filter: null,
        lfo: null,
        lfoGain: null,
        playing: false,
        
        // Create the ambient pad sound
        createPad: function(pitch, mode) {
            // Create nodes
            this.gainNode = audioContext.createGain();
            this.filter = audioContext.createBiquadFilter();
            this.lfo = audioContext.createOscillator();
            this.lfoGain = audioContext.createGain();
            
            // Configure filter (low-pass for dark, warm sound)
            this.filter.type = 'lowpass';
            
            // Adjust filter frequency based on pitch to add more bass for higher notes
            const noteIndex = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'].indexOf(pitch);
            if (noteIndex >= 5) { // For F and above
                this.filter.frequency.value = 500; // Higher for more bass in higher notes
            } else { // For C, C#, D, D#, E
                this.filter.frequency.value = 400; // Lower for darker, more rounded tone
            }
            
            this.filter.Q.value = 0.3; // Very soft resonance for vocal-like quality
            
            // Configure LFO for subtle movement
            this.lfo.type = 'sine';
            this.lfo.frequency.value = 0.005; // Very slow movement for gentle breath-like effect
            this.lfoGain.gain.value = 15; // Minimal modulation for smoother sound
            
            // Connect LFO -> filter frequency
            this.lfo.connect(this.lfoGain);
            this.lfoGain.connect(this.filter.frequency);
            
            // Calculate frequencies based on pitch and mode
            const rootFreq = getFrequencyForNote(pitch);
            let frequencies = [];
            
            if (mode === 'major') {
                // Major: root + perfect fifth
                frequencies = [rootFreq, rootFreq * Math.pow(2, 7/12)]; // Perfect fifth
            } else {
                // Minor: root + just minor third (more pleasant than equal temperament)
                frequencies = [rootFreq, rootFreq * (6/5)]; // Just intonation minor third
            }
            
            // Create oscillators for each pitch
            this.oscillators = [];
            
            frequencies.forEach((freq, index) => {
                // Create multiple oscillators for breathy, vocal-like sound
                // Two sine oscillators slightly detuned for soft, warm sound
                const sine1 = audioContext.createOscillator();
                sine1.type = 'sine';
                sine1.frequency.value = freq;
                
                const sine2 = audioContext.createOscillator();
                sine2.type = 'sine';
                // Slightly detune (5 cents for breathy effect)
                sine2.frequency.value = freq * Math.pow(2, 5/1200); 
                
                // One very soft sub oscillator for foundation
                const sub = audioContext.createOscillator();
                sub.type = 'sine';
                sub.frequency.value = freq * 0.5;
                // Reduce volume of sub oscillator to make it very subtle
                const subGain = audioContext.createGain();
                subGain.gain.value = 0.3; // Make sub oscillator much quieter
                sub.connect(subGain);
                
                // Connect all to filter
                sine1.connect(this.filter);
                sine2.connect(this.filter);
                subGain.connect(this.filter);
                
                // Store oscillators and gains
                this.oscillators.push({sine1, sine2, sub: {osc: sub, gain: subGain}});
            });
            
            // Connect filter -> gain -> destination
            this.filter.connect(this.gainNode);
            this.gainNode.connect(audioContext.destination);
            
            // Set initial volume
            this.gainNode.gain.value = 0; // Start silent for smooth fade-in
            
            // Start all oscillators
            this.oscillators.forEach(oscSet => {
                oscSet.sine1.start();
                oscSet.sine2.start();
                oscSet.sub.osc.start();
            });
            
            this.lfo.start();
            
            // Set initial volume based on padVolume
            this.gainNode.gain.value = 0; // Start silent for smooth fade-in
            
            // Start playing
            this.playing = true;
            
            // Fade in
            this.fadeIn();
        },
        
        // Fade in the pad
        fadeIn: function() {
            if (!this.gainNode) return;
            
            const now = audioContext.currentTime;
            const fadeInTime = 0.5; // 0.5 seconds fade in for quicker response
            
            // Exponential fade in for smoothness
            this.gainNode.gain.cancelScheduledValues(now);
            this.gainNode.gain.setValueAtTime(0, now);
            // Apply volume limit (below harsh threshold) during fade in
            const limitedVolume = Math.min(padVolume, 0.4); // Ensure volume stays below harsh threshold
            this.gainNode.gain.exponentialRampToValueAtTime(limitedVolume, now + fadeInTime);
        },
        
        // Fade out the pad
        fadeOut: function() {
            if (!this.gainNode) return;
            
            const now = audioContext.currentTime;
            const fadeOutTime = 0.5; // 0.5 seconds fade out (faster to prevent residue)
            
            // Exponential fade out for smoothness
            this.gainNode.gain.cancelScheduledValues(now);
            this.gainNode.gain.setValueAtTime(this.gainNode.gain.value, now);
            this.gainNode.gain.exponentialRampToValueAtTime(0.001, now + fadeOutTime);
            
            // Schedule cleanup after fade out completes
            setTimeout(() => {
                if (this.playing) { // Only cleanup if still playing
                    this.cleanup();
                }
            }, fadeOutTime * 1000);
        },
        
        // Switch to new pitch (immediate stop and start)
        switchToPitch: function(newPitch, newMode) {
            // Stop the current pad immediately
            this.stop();
            
            // Create new pad immediately
            this.createPad(newPitch, newMode);
        },
        
        // Change mode without changing pitch
        changeMode: function(newMode) {
            if (!this.playing) return;
            
            // Get the current pitch from the pad's internal state
            // Since we don't have a direct way to get it, we'll need to track it differently
            // For now, we'll use the global variable since that's what's available
            if (!currentPadPitch) return;
            
            // Stop the current pad immediately
            this.stop();
            
            // Create new pad with same pitch but new mode
            this.createPad(currentPadPitch, newMode);
        },
        
        // Update volume
        setVolume: function(volume) {
            padVolume = volume;
            if (this.gainNode && this.playing) {
                this.gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                this.gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            }
        },
        
        // Stop the pad
        stop: function() {
            if (!this.playing) return;
            
            // Immediate stop without fade out
            try {
                // Stop all oscillators immediately
                this.oscillators.forEach(oscSet => {
                    if (oscSet.sine1) {
                        try { oscSet.sine1.stop(); } catch(e) {}
                    }
                    if (oscSet.sine2) {
                        try { oscSet.sine2.stop(); } catch(e) {}
                    }
                    if (oscSet.sub && oscSet.sub.osc) {
                        try { oscSet.sub.osc.stop(); } catch(e) {}
                    }
                });
                
                // Also stop the LFO
                if (this.lfo) {
                    try { this.lfo.stop(); } catch(e) {}
                }
            } catch (e) {
                console.warn('Error stopping oscillators:', e);
            }
            
            // Then cleanup
            this.cleanup();
            
            // Update status
            updatePadStatus('Inactive');
        },
        
        // Clean up all nodes
        cleanup: function() {
            try {
                if (this.lfo) {
                    try { this.lfo.stop(); } catch(e) {}
                    try { this.lfo.disconnect(); } catch(e) {}
                }
                
                this.oscillators.forEach(oscSet => {
                    if (oscSet.sine1) {
                        try { oscSet.sine1.stop(); } catch(e) {}
                        try { oscSet.sine1.disconnect(); } catch(e) {}
                    }
                    if (oscSet.sine2) {
                        try { oscSet.sine2.stop(); } catch(e) {}
                        try { oscSet.sine2.disconnect(); } catch(e) {}
                    }
                    if (oscSet.sub && oscSet.sub.osc) {
                        try { oscSet.sub.osc.stop(); } catch(e) {}
                        try { oscSet.sub.osc.disconnect(); } catch(e) {}
                        // Also disconnect the sub gain node
                        if (oscSet.sub.gain) {
                            try { oscSet.sub.gain.disconnect(); } catch(e) {}
                        }
                    }
                });
                
                if (this.filter) {
                    try { this.filter.disconnect(); } catch(e) {}
                }
                
                if (this.gainNode) {
                    try { this.gainNode.disconnect(); } catch(e) {}
                }
                
                if (this.lfoGain) {
                    try { this.lfoGain.disconnect(); } catch(e) {}
                }
            } catch (e) {
                console.warn('Error during cleanup:', e);
            }
            
            this.playing = false;
            this.oscillators = [];
            
            // Clear references
            this.lfo = null;
            this.filter = null;
            this.gainNode = null;
            this.lfoGain = null;
        }
    };
}

// Pitch detection variables
let pitchDetectionAnalyser = null;
let pitchDetectionScriptProcessor = null;
let pitchDetectionSource = null;
let microphoneStream = null;
let isDetectingPitch = false;

// Variables for improved pitch detection
let pitchEstimates = [];
let detectionStartTime = null;
let stablePitchDetected = false;
const PITCH_DETECTION_WINDOW = 1000; // Collect estimates for 1 second
const STABLE_DURATION_MS = 300; // Require stability for 300ms
const CENT_TOLERANCE = 30; // A�30 cents tolerance
const MIN_AMPLITUDE = 0.01; // Minimum amplitude to consider a signal

// Function to start pitch detection
async function startPitchDetection() {
    try {
        // Request microphone access
        microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Create audio context if it doesn't exist
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            loadMetronomeSound();
        }
        
        // Create analyser node for pitch detection
        pitchDetectionAnalyser = audioContext.createAnalyser();
        pitchDetectionAnalyser.fftSize = 2048;
        
        // Create script processor for real-time processing
        pitchDetectionScriptProcessor = audioContext.createScriptProcessor(2048, 1, 1);
        pitchDetectionScriptProcessor.onaudioprocess = detectPitch;
        
        // Connect microphone -> analyser -> script processor
        pitchDetectionSource = audioContext.createMediaStreamSource(microphoneStream);
        pitchDetectionSource.connect(pitchDetectionAnalyser);
        pitchDetectionAnalyser.connect(pitchDetectionScriptProcessor);
        pitchDetectionScriptProcessor.connect(audioContext.destination); // Connect to destination to prevent audio drop
        
        isDetectingPitch = true;
        stablePitchDetected = false;
        pitchEstimates = [];
        detectionStartTime = Date.now();
        
        document.getElementById('tap-to-hum').textContent = 'Listening...';
        document.getElementById('tap-to-hum').classList.add('btn-warning');
        document.getElementById('tap-to-hum').classList.remove('btn-secondary');
        
        // Clear previous detection
        document.getElementById('detected-pitch-value').textContent = 'Listening...';
        document.getElementById('use-detected-pitch').style.display = 'none';
        
    } catch (err) {
        console.error('Error accessing microphone:', err);
        alert('Could not access microphone. Please ensure you have granted permission and have a microphone connected.');
        stopPitchDetection();
    }
}

// Function to stop pitch detection
function stopPitchDetection() {
    if (microphoneStream) {
        microphoneStream.getTracks().forEach(track => track.stop());
        microphoneStream = null;
    }
    
    if (pitchDetectionSource) {
        pitchDetectionSource.disconnect();
        pitchDetectionSource = null;
    }
    
    if (pitchDetectionScriptProcessor) {
        pitchDetectionScriptProcessor.disconnect();
        pitchDetectionScriptProcessor.onaudioprocess = null;
        pitchDetectionScriptProcessor = null;
    }
    
    if (pitchDetectionAnalyser) {
        pitchDetectionAnalyser.disconnect();
        pitchDetectionAnalyser = null;
    }
    
    isDetectingPitch = false;
    stablePitchDetected = false;
    pitchEstimates = [];
    detectionStartTime = null;
    
    document.getElementById('tap-to-hum').textContent = 'Tap to Hum';
    document.getElementById('tap-to-hum').classList.add('btn-secondary');
    document.getElementById('tap-to-hum').classList.remove('btn-warning');
}

// YIN-based pitch detection algorithm with audio preprocessing
function detectPitch(event) {
    if (!isDetectingPitch) return;
    
    const inputData = event.inputBuffer.getChannelData(0);
    const sampleRate = audioContext.sampleRate;
    
    // Audio preprocessing: band-pass filter (80 Hz to 1200 Hz)
    const filteredData = applyBandPassFilter(inputData, sampleRate, 80, 1200);
    
    // Calculate RMS amplitude to check for signal
    const rms = Math.sqrt(filteredData.reduce((sum, val) => sum + val * val, 0) / filteredData.length);
    
    // Skip if RMS is below threshold
    const rmsThreshold = 0.01; // Adjust as needed
    if (rms < rmsThreshold) return;
    
    // YIN algorithm implementation
    const probabilityThreshold = 0.1;
    const tauEstimate = computeYin(filteredData, sampleRate, 80, 1200, probabilityThreshold);
    
    if (tauEstimate !== null) {
        const frequency = sampleRate / tauEstimate;
        
        // Validate frequency is in reasonable range
        if (frequency >= 80 && frequency <= 1200) { // Within our band-pass filter range
            // Add the frequency estimate to our collection
            pitchEstimates.push({
                frequency: frequency,
                timestamp: Date.now()
            });
            
            // Filter out estimates older than 800ms
            const now = Date.now();
            pitchEstimates = pitchEstimates.filter(estimate => now - estimate.timestamp <= 800);
            
            // If we have enough estimates, process them
            if (pitchEstimates.length >= 3) { // Need at least 3 estimates to process
                // Sort by frequency to calculate median
                const sortedEstimates = [...pitchEstimates].sort((a, b) => a.frequency - b.frequency);
                
                // Calculate median frequency
                const medianIndex = Math.floor(sortedEstimates.length / 2);
                const medianFrequency = sortedEstimates[medianIndex].frequency;
                
                // If we have enough stable estimates, report the pitch
                if (sortedEstimates.length >= 5) { // Require at least 5 estimates for stability
                    // Calculate interquartile range to check stability
                    const q1Index = Math.floor(sortedEstimates.length / 4);
                    const q3Index = Math.floor(3 * sortedEstimates.length / 4);
                    const q1 = sortedEstimates[q1Index].frequency;
                    const q3 = sortedEstimates[q3Index].frequency;
                    const iqr = q3 - q1;
                    
                    // Check if the frequency range is stable (within 30 cents)
                    const minFreq = sortedEstimates[0].frequency;
                    const maxFreq = sortedEstimates[sortedEstimates.length - 1].frequency;
                    
                    // Convert to cents difference
                    const maxCentsDiff = 1200 * Math.log2(maxFreq / minFreq);
                    
                    if (Math.abs(maxCentsDiff) <= CENT_TOLERANCE && !stablePitchDetected) {
                        // We have a stable pitch!
                        stablePitchDetected = true;
                        
                        // Use the median frequency as our final result
                        const finalNote = frequencyToNote(medianFrequency);
                        
                        // Update UI with detected pitch
                        document.getElementById('detected-pitch-value').textContent = `${finalNote.note} (${Math.round(medianFrequency)} Hz)`;
                        
                        // Store the detected pitch for later use
                        window.detectedPitch = finalNote.pitch;
                        
                        // Show the button to use the detected pitch
                        document.getElementById('use-detected-pitch').style.display = 'block';
                        
                        // Stop detection after a good reading
                        setTimeout(() => {
                            if (isDetectingPitch) {
                                stopPitchDetection();
                            }
                        }, 2000); // Stop after 2 seconds to allow for longer listening
                    }
                }
            }
        }
    }
}

// Band-pass filter implementation using biquad filters
function applyBandPassFilter(data, sampleRate, lowFreq, highFreq) {
    // Simple implementation: apply high-pass and low-pass filters
    const filtered = new Float32Array(data.length);
    
    // High-pass filter (remove low frequencies below 80Hz)
    let y1 = 0, x1 = 0;
    const highPassFreq = 2 * Math.tan(Math.PI * lowFreq / sampleRate);
    const a0_hp = 1 + highPassFreq / 2;
    const b0_hp = 1 / a0_hp;
    const b1_hp = -1 / a0_hp;
    
    for (let i = 0; i < data.length; i++) {
        const x0 = data[i];
        const y0 = b0_hp * x0 + b1_hp * x1 - (1 - highPassFreq / 2) / a0_hp * y1;
        y1 = y0;
        x1 = x0;
        filtered[i] = y0;
    }
    
    // Low-pass filter (remove high frequencies above 1200Hz)
    let y2 = 0, x2 = 0;
    const lowPassFreq = 2 * Math.tan(Math.PI * highFreq / sampleRate);
    const a0_lp = 1 + lowPassFreq / 2;
    const b0_lp = lowPassFreq / 2 / a0_lp;
    const b1_lp = lowPassFreq / 2 / a0_lp;
    
    for (let i = filtered.length - 1; i >= 0; i--) {
        const x0 = filtered[i];
        const y0 = b0_lp * x0 + b1_lp * x2 - (1 - lowPassFreq / 2) / a0_lp * y2;
        y2 = y0;
        x2 = x0;
        filtered[i] = y0;
    }
    
    return filtered;
}

// YIN pitch detection algorithm
function computeYin(buffer, sampleRate, minFreq, maxFreq, probabilityThreshold) {
    const bufferSize = buffer.length;
    const yinBuffer = new Float32Array(bufferSize >> 1); // Half the size
    
    // Compute difference function
    for (let tau = 0; tau < bufferSize >> 1; tau++) {
        yinBuffer[tau] = 0;
        for (let j = 0; j < bufferSize >> 1; j++) {
            const delta = buffer[j] - buffer[j + tau];
            yinBuffer[tau] += delta * delta;
        }
    }
    
    // Compute cumulative mean normalized difference function
    yinBuffer[0] = 1;
    let runningSum = 0;
    for (let tau = 1; tau < bufferSize >> 1; tau++) {
        runningSum += yinBuffer[tau];
        if (runningSum === 0) {
            yinBuffer[tau] = 1;
        } else {
            yinBuffer[tau] *= tau / runningSum;
        }
    }
    
    // Find absolute threshold
    let tau = -1;
    for (let i = 1; i < bufferSize >> 1; i++) {
        if (yinBuffer[i] < probabilityThreshold) {
            while (i + 1 < bufferSize >> 1 && yinBuffer[i + 1] < yinBuffer[i]) {
                i++;
            }
            tau = i;
            break;
        }
    }
    
    // If no pitch found within range, return null
    if (tau === -1) {
        return null;
    }
    
    // Interpolate for better accuracy
    const period1 = tau;
    const period2 = tau > 0 ? tau - 1 : tau;
    const period3 = tau < yinBuffer.length - 1 ? tau + 1 : tau;
    
    if (period1 === 0) return period1;
    
    const x = (yinBuffer[period2] - yinBuffer[period3]) / (yinBuffer[period3] - yinBuffer[period1]);
    const tauEstimate = period1 + x;
    
    // Verify the estimated period is within our frequency range
    const estimatedFreq = sampleRate / tauEstimate;
    if (estimatedFreq < minFreq || estimatedFreq > maxFreq) {
        return null;
    }
    
    return tauEstimate;
}

// Convert frequency to closest musical note
function frequencyToNote(frequency) {
    const A4 = 440;
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    
    // Calculate the number of half steps from A4
    const halfSteps = 12 * Math.log2(frequency / A4);
    const noteIndex = Math.round(halfSteps) % 12;
    const octave = Math.floor(Math.round(halfSteps) / 12) + 4;
    
    // Adjust negative modulo
    const adjustedNoteIndex = ((noteIndex % 12) + 12) % 12;
    
    return {
        note: notes[adjustedNoteIndex],
        pitch: notes[adjustedNoteIndex]
    };
}

// Helper function to get frequency for a note
function getFrequencyForNote(note) {
    // A4 = 440Hz
    const A4 = 440;
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    
    // Extract note and octave
    let noteName = note;
    let octave = 4; // Default octave
    
    // Check if the last character is a number (octave indicator)
    const lastChar = note.charAt(note.length - 1);
    if (!isNaN(lastChar) && lastChar !== ' ' && note.length > 1) {
        // If the note has an octave number
        noteName = note.substring(0, note.length - 1);
        octave = parseInt(lastChar);
    }
    
    const noteIndex = notes.indexOf(noteName);
    if (noteIndex === -1) return A4; // Default to A4 if not found
    
    // Calculate semitones from A4
    const semitonesFromA = noteIndex - 9; // A is at index 9
    const semitonesFromA4 = semitonesFromA + (octave - 4) * 12;
    
    // Calculate frequency
    return A4 * Math.pow(2, semitonesFromA4 / 12);
}

let currentSong = null;
let currentSetlist = null;
let editingSongId = null;
let editingSetlistId = null;
let cameFromViewSetlist = false;
let transposeValue = 0;
let metronomeBuffer = null;
let metronomeVolume = 50; // Default volume (0-100)

// Ambient Pad variables
let ambientPad = null;
let currentPadPitch = null;
let currentPadMode = 'major'; // Default to major
let padVolume = 0.25; // Default volume (0-0.4, which is below harsh threshold)

// Update pad status function
function updatePadStatus(status) {
    const statusElement = document.getElementById('pad-status');
    if (statusElement) {
        statusElement.textContent = status;
    }
    
    // Update ambient toggle button appearance
    const ambientToggle = document.getElementById('ambient-toggle');
    if (ambientToggle) {
        if (status === 'Inactive') {
            ambientToggle.classList.remove('btn-primary');
            ambientToggle.classList.add('btn-secondary');
        } else {
            ambientToggle.classList.remove('btn-secondary');
            ambientToggle.classList.add('btn-primary');
        }
    }
}

// Function to initialize the ambient toggle button state
function updateAmbientToggleState() {
    const ambientToggle = document.getElementById('ambient-toggle');
    if (ambientToggle) {
        if (ambientPad && ambientPad.playing) {
            ambientToggle.classList.remove('btn-secondary');
            ambientToggle.classList.add('btn-primary');
        } else {
            ambientToggle.classList.remove('btn-primary');
            ambientToggle.classList.add('btn-secondary');
        }
    }
}

/* ---------- elements ---------- */
const homeSongsPage = document.getElementById('home-songs-page');
const homeSetlistsPage = document.getElementById('home-setlists-page');
const editSongPage = document.getElementById('edit-song-page');
const editSetlistPage = document.getElementById('edit-setlist-page');
const viewSetlistPage = document.getElementById('view-setlist-page');
const lyricsPage = document.getElementById('lyrics-page');
const settingsPage = document.getElementById('settings-page');
const ambientModal = document.getElementById('ambient-modal');

/* ---------- events ---------- */
document.getElementById('songs-tab').addEventListener('click', showSongsPage);
document.getElementById('setlists-tab').addEventListener('click', showSetlistsPage);
document.getElementById('setlists-tab-active').addEventListener('click', showSetlistsPage);
document.getElementById('back-to-songs-tab').addEventListener('click', showSongsPage);
document.getElementById('back-to-songs-from-lyrics').addEventListener('click', function() {
    // Turn off metronome when exiting lyrics page
    const metronomeBtn = document.getElementById('metronome-toggle');
    if (metronomeBtn && metronomeBtn.classList.contains('active')) {
        metronomeBtn.classList.remove('active');
        console.log('Metronome OFF');
    }
    
    // Turn off ambient pad when exiting lyrics page
    if (ambientPad) {
        ambientPad.stop();
        ambientPad = null;
    }
    currentPadPitch = null;
    
    // Update ambient toggle button appearance
    updateAmbientToggleState();
    
    if (currentSetlist && window.currentSetlistContext) {
        showViewSetlistPage(currentSetlist);
    } else {
        showSongsPage();
    }
});
document.getElementById('back-to-setlists-from-view').addEventListener('click', function() {
    // Turn off metronome when exiting lyrics page
    const metronomeBtn = document.getElementById('metronome-toggle');
    if (metronomeBtn && metronomeBtn.classList.contains('active')) {
        metronomeBtn.classList.remove('active');
        console.log('Metronome OFF');
    }
    
    // Turn off ambient pad when exiting lyrics page
    if (ambientPad) {
        ambientPad.stop();
        ambientPad = null;
    }
    currentPadPitch = null;
    
    // Update ambient toggle button appearance
    updateAmbientToggleState();
    
    showSetlistsPage();
});
document.getElementById('back-to-home-from-settings').addEventListener('click', showSongsPage);
document.getElementById('prev-song-btn').addEventListener('click', navigateToPrevSong);
document.getElementById('next-song-btn').addEventListener('click', navigateToNextSong);

// Menu functionality for lyrics page
document.querySelector('#lyrics-page .menu-icon').addEventListener('click', function(e) {
    e.stopPropagation();
    document.querySelector('#lyrics-page .dropdown-menu').classList.toggle('hidden');
});

// Menu functionality for view setlist page
document.querySelectorAll('#view-setlist-page .menu-icon')[0].addEventListener('click', function(e) {
    e.stopPropagation();
    const dropdown = e.target.closest('.menu-container').querySelector('.dropdown-menu');
    dropdown.classList.toggle('hidden');
});

document.getElementById('edit-song-menu-item').addEventListener('click', function() {
    if (currentSong) {
        editSong(currentSong);
    }
    document.querySelector('.dropdown-menu').classList.add('hidden');
});

document.getElementById('delete-song-menu-item').addEventListener('click', function() {
    if (currentSong && confirm('Are you sure you want to delete this song?')) {
        songs = songs.filter(s => s.id !== currentSong.id);
        localStorage.setItem('setlistManager_songs', JSON.stringify(songs));
        renderSongsList();
        showSongsPage();
    }
    document.querySelector('.dropdown-menu').classList.add('hidden');
});

// Close menu when clicking elsewhere
document.addEventListener('click', function(e) {
    if (!e.target.closest('.menu-container')) {
        document.querySelectorAll('.dropdown-menu').forEach(menu => {
            menu.classList.add('hidden');
        });
    }
});

// Edit setlist menu item
document.getElementById('edit-setlist-menu-item').addEventListener('click', function() {
    if (currentSetlist) {
        showEditSetlistPage(currentSetlist, true);
    }
    document.querySelector('.dropdown-menu').classList.add('hidden');
});

// Home page menu items
// Songs page menu items
document.getElementById('settings-menu-item').addEventListener('click', function() {
    showSettingsPage();
    document.querySelector('.dropdown-menu').classList.add('hidden');
});

// Setlists page menu items
document.getElementById('settings-menu-item-2').addEventListener('click', function() {
    showSettingsPage();
    document.querySelector('.dropdown-menu').classList.add('hidden');
});

// Check auth state before allowing to add song
async function checkAuthBeforeAddSong() {
    try {
        if (window.db) {
            const { data: { user }, error } = await window.db.auth.getUser();
            if (user) {
                // User is logged in, allow adding song
                createNewSong();
            } else {
                // User is not logged in, show auth page
                showAuthPage();
            }
        } else {
            // DB not initialized, show auth page
            showAuthPage();
        }
    } catch (error) {
        console.error('Error checking auth state:', error);
        showAuthPage();
    }
}

// Event listener for add song button is set in the DOMContentLoaded event
document.getElementById('cancel-edit-btn').addEventListener('click', function() {
    if (window.fromLyricsPage && currentSong) {
        // Go back to the lyrics page
        showLyricsPage(currentSong);
        window.fromLyricsPage = false;
    } else {
        // Go back to the songs page
        showSongsPage();
    }
});
document.getElementById('save-song-btn').addEventListener('click', saveSong);
document.getElementById('delete-song-btn').addEventListener('click', deleteSong);
document.getElementById('duplicate-song-btn').addEventListener('click', duplicateSong);

document.getElementById('cancel-edit-setlist-btn').addEventListener('click', function() {
  if (cameFromViewSetlist && currentSetlist) {
    showViewSetlistPage(currentSetlist);
  } else {
    showSetlistsPage();
  }
});
document.getElementById('save-setlist-btn').addEventListener('click', saveSetlist);
document.getElementById('delete-setlist-btn').addEventListener('click', deleteSetlist);

// Ambient pad toggle and dropdown functionality
    document.getElementById('ambient-toggle').addEventListener('click', function() {
        // Toggle the ambient pad on/off with last selected pitch
        if (ambientPad && ambientPad.playing) {
            // If pad is currently playing, stop it
            ambientPad.stop();
            ambientPad = null;
            currentPadPitch = null;
            
            // Update UI
            document.querySelectorAll('#pitch-buttons .pitch-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            updatePadStatus('Inactive');
            
            // Update button appearance
            this.classList.remove('btn-primary');
            this.classList.add('btn-secondary');
        } else {
            // If no pad is currently playing, start with last selected pitch or default
            if (!currentPadPitch) {
                // Default to C major if no pitch has been selected yet
                currentPadPitch = 'C';
                currentPadMode = 'major';
            }
            
            ambientPad = initAmbientPad();
            if (ambientPad) {
                ambientPad.createPad(currentPadPitch, currentPadMode);
                
                // Update button appearance
                this.classList.remove('btn-secondary');
                this.classList.add('btn-primary');
            }
        }
    });
    
    // Ambient dropdown event listener is handled in main.js
    // document.getElementById('ambient-dropdown').addEventListener('click', function() {
    //     showAmbientPad();
    // });
document.getElementById('close-ambient-modal').addEventListener('click', hideAmbientPad);

// Tap to hum functionality
document.getElementById('tap-to-hum').addEventListener('click', function() {
    if (isDetectingPitch) {
        // If already detecting, stop it
        stopPitchDetection();
    } else {
        // Turn off the ambient pad if it's currently playing
        if (ambientPad && ambientPad.playing) {
            ambientPad.stop();
            ambientPad = null;
            currentPadPitch = null;
            
            // Update UI to reflect that pad is off
            document.querySelectorAll('#pitch-buttons .pitch-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            updatePadStatus('Inactive');
            
            // Update the ambient toggle button appearance
            updateAmbientToggleState();
        }
        
        // Start pitch detection
        startPitchDetection();
    }
});

// Use detected pitch functionality
document.getElementById('use-detected-pitch').addEventListener('click', function() {
    if (window.detectedPitch) {
        // Set the current pad pitch to the detected pitch
        currentPadPitch = window.detectedPitch;
        
        // If ambient pad is currently playing, restart it with the new pitch
        if (ambientPad && ambientPad.playing) {
            ambientPad.stop();
            ambientPad = initAmbientPad();
            if (ambientPad) {
                ambientPad.createPad(currentPadPitch, currentPadMode);
                
                // Update the ambient toggle button appearance
                updateAmbientToggleState();
            }
        } else {
            // If ambient pad is not currently playing, start it with the detected pitch
            ambientPad = initAmbientPad();
            if (ambientPad) {
                ambientPad.createPad(currentPadPitch, currentPadMode);
                
                // Update the ambient toggle button appearance
                updateAmbientToggleState();
            }
        }
        
        // Highlight the detected pitch button in the modal
        document.querySelectorAll('#pitch-buttons .pitch-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        const detectedPitchBtn = document.querySelector(`#pitch-buttons .pitch-btn[data-pitch="${window.detectedPitch}"]`);
        if (detectedPitchBtn) {
            detectedPitchBtn.classList.add('active');
        }
        
        // Update the pad status
        updatePadStatus(`Active: ${window.detectedPitch} ${currentPadMode}`);
        
        // Show confirmation
        document.getElementById('detected-pitch-value').textContent = `Using ${window.detectedPitch}`;
        
        // Hide the button after use
        setTimeout(() => {
            document.getElementById('use-detected-pitch').style.display = 'none';
        }, 2000);
    }
});


document.getElementById('song-search').addEventListener('input', filterSongs);
document.getElementById('setlist-search').addEventListener('input', filterSetlists);
document.getElementById('add-song-search').addEventListener('input', filterAvailableSongs);

// Clear search button functionality
document.getElementById('clear-song-search').addEventListener('click', function() {
    document.getElementById('song-search').value = '';
    filterSongs();
    this.classList.add('hidden');
});

document.getElementById('clear-setlist-search').addEventListener('click', function() {
    document.getElementById('setlist-search').value = '';
    filterSetlists();
    this.classList.add('hidden');
});

document.getElementById('clear-add-song-search').addEventListener('click', function() {
    document.getElementById('add-song-search').value = '';
    filterAvailableSongs();
    this.classList.add('hidden');
});

document.getElementById('dark-mode-toggle').addEventListener('change', function() {
    const isDarkMode = this.checked;
    // Save preference to localStorage
    localStorage.setItem('setlistManager_darkMode', isDarkMode);
    if (isDarkMode) {
        document.body.classList.add('dark-mode');
    } else {
        document.body.classList.remove('dark-mode');
    }
});

// Metronome volume control
const metronomeVolumeSlider = document.getElementById('metronome-volume');
const metronomeVolumeValue = document.getElementById('metronome-volume-value');
if (metronomeVolumeSlider && metronomeVolumeValue) {
    metronomeVolumeSlider.addEventListener('input', function() {
        metronomeVolume = parseInt(this.value);
        metronomeVolumeValue.textContent = metronomeVolume;
        // Save preference to localStorage
        localStorage.setItem('setlistManager_metronomeVolume', metronomeVolume);
    });
}

/* ---------- init ---------- */
document.addEventListener('DOMContentLoaded', function() {
    renderSongsList();
    renderSetlistsList();
    renderPitchButtons();
    document.getElementById('add-setlist-btn').addEventListener('click', checkAuthBeforeAddSetlist);
    document.getElementById('add-song-btn')?.addEventListener('click', checkAuthBeforeAddSong);
    const metronomeBtn = document.getElementById('metronome-toggle');
    if (metronomeBtn) metronomeBtn.addEventListener('click', toggleMetronome);
    const transposeUpBtn = document.getElementById('transpose-up-lyrics');
    const transposeDownBtn = document.getElementById('transpose-down-lyrics');
    if (transposeUpBtn && transposeDownBtn) {
        transposeUpBtn.addEventListener('click', () => transposeLyrics(1));
        transposeDownBtn.addEventListener('click', () => transposeLyrics(-1));
    }
    
    // Load dark mode preference
    const savedDarkMode = localStorage.getItem('setlistManager_darkMode') === 'true';
    if (savedDarkMode) {
        document.body.classList.add('dark-mode');
        // Update toggle switch state
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        if (darkModeToggle) {
            darkModeToggle.checked = true;
        }
    }
    
    // Load metronome volume preference
    const savedMetronomeVolume = localStorage.getItem('setlistManager_metronomeVolume');
    if (savedMetronomeVolume !== null) {
        metronomeVolume = parseInt(savedMetronomeVolume);
        const metronomeVolumeSlider = document.getElementById('metronome-volume');
        const metronomeVolumeValue = document.getElementById('metronome-volume-value');
        if (metronomeVolumeSlider && metronomeVolumeValue) {
            metronomeVolumeSlider.value = metronomeVolume;
            metronomeVolumeValue.textContent = metronomeVolume;
        }
    }
    
    // Initialize default mode selection for ambient pad
    const majorButton = document.querySelector('[data-mode="major"]');
    if (majorButton) {
        majorButton.classList.add('active');
    }
    
    // Ambient pad event listeners
    const volumeSlider = document.getElementById('volume-slider');
    if (volumeSlider) {
        volumeSlider.addEventListener('input', function() {
            // Convert 0-100 to 0-0.4 (below harsh threshold) linearly
            const volume = (this.value / 100) * 0.4;
            if (ambientPad) {
                ambientPad.setVolume(volume);
            }
        });
    }
    

    
    // Add event listeners to mode buttons
    document.querySelectorAll('[data-mode]').forEach(button => {
        button.addEventListener('click', function() {
            const mode = this.getAttribute('data-mode');
            currentPadMode = mode;
            
            // Update UI
            document.querySelectorAll('[data-mode]').forEach(btn => {
                btn.classList.remove('active');
            });
            this.classList.add('active');
            
            // If pad is playing, change mode while keeping same pitch
            if (ambientPad && currentPadPitch) {
                ambientPad.changeMode(mode);
            }
        });
    });
    

    
    // Autoscroll functionality
    const autoscrollToggle = document.getElementById('autoscroll-toggle');
    const autoscrollLevel = document.getElementById('autoscroll-level');
    
    if (autoscrollToggle && autoscrollLevel) {
        // Toggle autoscroll on/off
        autoscrollToggle.addEventListener('click', function() {
            const isOn = this.textContent === 'On';
            if (isOn) {
                // Turn off
                this.textContent = 'Off';
                this.classList.remove('btn-primary');
                this.classList.add('btn-secondary');
                autoscrollLevel.disabled = true;
                stopAutoscroll();
            } else {
                // Turn on
                this.textContent = 'On';
                this.classList.remove('btn-secondary');
                this.classList.add('btn-primary');
                autoscrollLevel.disabled = false;
                const level = parseInt(autoscrollLevel.value);
                startAutoscroll(level);
            }
        });
        
        // Change autoscroll level
        autoscrollLevel.addEventListener('change', function() {
            if (autoscrollToggle.textContent === 'On') {
                const level = parseInt(this.value);
                stopAutoscroll();
                startAutoscroll(level);
            }
        });
    }
    
    // Home page menu functionality
    // Using a more direct approach to ensure the menu works
    document.addEventListener('click', function(e) {
        // Check if click is on an account menu item
        if (e.target.id === 'account-menu-item-songs' || e.target.id === 'account-menu-item-setlists') {
            // Allow the event to propagate to the specific handler
            return;
        }
        
        // Handle songs page menu
        if (e.target.closest('#home-songs-page .menu-icon')) {
            e.stopPropagation();
            const menuContainer = e.target.closest('#home-songs-page .menu-container');
            const dropdown = menuContainer ? menuContainer.querySelector('.dropdown-menu') : null;
            if (dropdown) {
                // Close all other menus first
                document.querySelectorAll('.dropdown-menu').forEach(menu => {
                    if (menu !== dropdown) {
                        menu.classList.add('hidden');
                    }
                });
                dropdown.classList.toggle('hidden');
            }
        }
        
        // Handle setlists page menu
        if (e.target.closest('#home-setlists-page .menu-icon')) {
            e.stopPropagation();
            const menuContainer = e.target.closest('#home-setlists-page .menu-container');
            const dropdown = menuContainer ? menuContainer.querySelector('.dropdown-menu') : null;
            if (dropdown) {
                // Close all other menus first
                document.querySelectorAll('.dropdown-menu').forEach(menu => {
                    if (menu !== dropdown) {
                        menu.classList.add('hidden');
                    }
                });
                dropdown.classList.toggle('hidden');
            }
        }
        
        // Close dropdowns when clicking elsewhere
        if (!e.target.closest('.menu-icon') && !e.target.closest('.dropdown-menu')) {
            document.querySelectorAll('.dropdown-menu').forEach(menu => {
                menu.classList.add('hidden');
            });
        }
    });
});

/* ---------- navigation ---------- */
function showSongsPage() { 
    // Turn off metronome when exiting lyrics page
    stopMetronome();
    const metronomeBtn = document.getElementById('metronome-toggle');
    if (metronomeBtn && metronomeBtn.classList.contains('active')) {
        metronomeBtn.classList.remove('active');
    }
    stopAutoscroll();
    homeSongsPage.classList.remove('hidden');
    homeSetlistsPage.classList.add('hidden');
    editSongPage.classList.add('hidden');
    editSetlistPage.classList.add('hidden');
    viewSetlistPage.classList.add('hidden');
    lyricsPage.classList.add('hidden');
    settingsPage.classList.add('hidden');
    ambientModal.classList.add('hidden');
    // Make sure auth page is hidden
    document.getElementById('auth-page')?.classList.add('hidden');
    clearSetlistContext();
}
function showSetlistsPage() { 
    // Turn off metronome when exiting lyrics page
    stopMetronome();
    const metronomeBtn = document.getElementById('metronome-toggle');
    if (metronomeBtn && metronomeBtn.classList.contains('active')) {
        metronomeBtn.classList.remove('active');
    }
    stopAutoscroll();
    homeSongsPage.classList.add('hidden');
    homeSetlistsPage.classList.remove('hidden');
    editSongPage.classList.add('hidden');
    editSetlistPage.classList.add('hidden');
    viewSetlistPage.classList.add('hidden');
    lyricsPage.classList.add('hidden');
    settingsPage.classList.add('hidden');
    ambientModal.classList.add('hidden');
    // Make sure auth page is hidden
    document.getElementById('auth-page')?.classList.add('hidden');
    clearSetlistContext();
}
function showViewSetlistPage(setlist) {
    stopMetronome();
    stopAutoscroll();
    homeSongsPage.classList.add('hidden');
    homeSetlistsPage.classList.add('hidden');
    editSongPage.classList.add('hidden');
    editSetlistPage.classList.add('hidden');
    viewSetlistPage.classList.remove('hidden');
    lyricsPage.classList.add('hidden');
    settingsPage.classList.add('hidden');
    ambientModal.classList.add('hidden');
    // Make sure auth page is hidden
    document.getElementById('auth-page')?.classList.add('hidden');
    currentSetlist = setlist;
    document.getElementById('view-setlist-title').textContent = setlist.title;
    renderViewSetlistSongs(setlist.songIds);
}
function showEditSongPage(song = null) {
    stopMetronome();
    stopAutoscroll();
    homeSongsPage.classList.add('hidden');
    homeSetlistsPage.classList.add('hidden');
    editSongPage.classList.remove('hidden');
    editSetlistPage.classList.add('hidden');
    lyricsPage.classList.add('hidden');
    settingsPage.classList.add('hidden');
    ambientModal.classList.add('hidden');
    // Make sure auth page is hidden
    document.getElementById('auth-page')?.classList.add('hidden');
    if (song) {
        editingSongId = song.id;
        document.getElementById('song-title').value = song.title;
        
        // Parse key to separate key and mode
        let key = song.key;
        let mode = 'major';
        if (key.endsWith('m')) {
            key = key.substring(0, key.length - 1); // Remove 'm'
            mode = 'minor';
        }
        
        document.getElementById('song-key').value = key;
        document.getElementById('song-mode').value = mode;
        document.getElementById('song-bpm').value = song.bpm || 120;  // Default to 120 if not provided
        document.getElementById('song-time-sig').value = song.timeSig;
        document.getElementById('song-lyrics').value = song.lyrics;
        document.getElementById('delete-song-btn').style.display = 'block';
    } else {
        editingSongId = null;
        document.getElementById('song-title').value = '';
        document.getElementById('song-key').value = 'C';
        document.getElementById('song-mode').value = 'major';
        document.getElementById('song-bpm').value = 120;  // Default for new songs
        document.getElementById('song-time-sig').value = '4/4';
        document.getElementById('song-lyrics').value = '';
        document.getElementById('delete-song-btn').style.display = 'none';
    }
}
function showLyricsPage(song) {
    console.log('showLyricsPage called with song:', song);
    stopMetronome();
    stopAutoscroll();
    // Reset autoscroll controls when showing a new song
    const autoscrollToggle = document.getElementById('autoscroll-toggle');
    const autoscrollLevel = document.getElementById('autoscroll-level');
    if (autoscrollToggle) {
        autoscrollToggle.textContent = 'Off';
        autoscrollToggle.classList.remove('btn-primary');
        autoscrollToggle.classList.add('btn-secondary');
    }
    if (autoscrollLevel) {
        autoscrollLevel.value = '1';
        autoscrollLevel.disabled = true;
    }
    
    homeSongsPage.classList.add('hidden');
    homeSetlistsPage.classList.add('hidden');
    editSongPage.classList.add('hidden');
    editSetlistPage.classList.add('hidden');
    viewSetlistPage.classList.add('hidden');
    lyricsPage.classList.remove('hidden');
    settingsPage.classList.add('hidden');
    ambientModal.classList.add('hidden');
    // Make sure auth page is hidden
    document.getElementById('auth-page')?.classList.add('hidden');
    
    // Reset transpose value when showing a new song
    transposeValue = 0;
    // Display with + prefix for positive values
    document.getElementById('transpose-value').textContent = (transposeValue > 0 ? '+' : '') + transposeValue;
    
    currentSong = songs.find(s => s.id === song.id) || song;
    console.log('Setting currentSong to:', currentSong);
    document.getElementById('lyrics-title').textContent = currentSong.title;
    document.getElementById('lyrics-details').textContent = `${currentSong.key} � ${currentSong.bpm} bpm`;
    
    // Set language attribute for Malayalam songs
    const lyricsContainer = document.getElementById('lyrics-content');
    if (currentSong.title.includes('Malayalam') || /[?-?]/.test(currentSong.lyrics)) {
        lyricsContainer.setAttribute('lang', 'ml');
    } else {
        lyricsContainer.removeAttribute('lang');
    }
    
    document.getElementById('lyrics-content').innerHTML = renderLyricsWithChords(currentSong.lyrics);
    // Hide navigation buttons by default
    document.getElementById('prev-song-btn').style.display = 'none';
    document.getElementById('next-song-btn').style.display = 'none';
    console.log('Lyrics page displayed for song:', currentSong.title);
}

function showLyricsPageFromSetlist(song, songIds, currentIndex) {
    stopMetronome();
    stopAutoscroll();
    // Reset autoscroll controls when showing a new song
    const autoscrollToggle = document.getElementById('autoscroll-toggle');
    const autoscrollLevel = document.getElementById('autoscroll-level');
    if (autoscrollToggle) {
        autoscrollToggle.textContent = 'Off';
        autoscrollToggle.classList.remove('btn-primary');
        autoscrollToggle.classList.add('btn-secondary');
    }
    if (autoscrollLevel) {
        autoscrollLevel.value = '1';
        autoscrollLevel.disabled = true;
    }
    
    homeSongsPage.classList.add('hidden');
    homeSetlistsPage.classList.add('hidden');
    editSongPage.classList.add('hidden');
    editSetlistPage.classList.add('hidden');
    viewSetlistPage.classList.add('hidden');
    lyricsPage.classList.remove('hidden');
    settingsPage.classList.add('hidden');
    ambientModal.classList.add('hidden');
    // Make sure auth page is hidden
    document.getElementById('auth-page')?.classList.add('hidden');
    
    // Reset transpose value when showing a new song
    transposeValue = 0;
    // Display with + prefix for positive values
    document.getElementById('transpose-value').textContent = (transposeValue > 0 ? '+' : '') + transposeValue;
    
    currentSong = songs.find(s => s.id === song.id) || song;
    document.getElementById('lyrics-title').textContent = currentSong.title;
    document.getElementById('lyrics-details').textContent = `${currentSong.key} � ${currentSong.bpm} bpm`;
    
    // Set language attribute for Malayalam songs
    const lyricsContainer = document.getElementById('lyrics-content');
    if (currentSong.title.includes('Malayalam') || /[?-?]/.test(currentSong.lyrics)) {
        lyricsContainer.setAttribute('lang', 'ml');
    } else {
        lyricsContainer.removeAttribute('lang');
    }
    
    document.getElementById('lyrics-content').innerHTML = renderLyricsWithChords(currentSong.lyrics);
    
    // Show navigation buttons with appropriate styling
    const prevBtn = document.getElementById('prev-song-btn');
    const nextBtn = document.getElementById('next-song-btn');
    
    // Reset button styles
    prevBtn.style.opacity = '1';
    prevBtn.style.pointerEvents = 'auto';
    nextBtn.style.opacity = '1';
    nextBtn.style.pointerEvents = 'auto';
    
    // Show/hide and fade buttons based on position
    if (currentIndex > 0) {
        prevBtn.style.display = 'block';
    } else {
        prevBtn.style.display = 'block';
        prevBtn.style.opacity = '0.5';
        prevBtn.style.pointerEvents = 'none';
    }
    
    if (currentIndex < songIds.length - 1) {
        nextBtn.style.display = 'block';
    } else {
        nextBtn.style.display = 'block';
        nextBtn.style.opacity = '0.5';
        nextBtn.style.pointerEvents = 'none';
    }
    
    // Store current setlist context for navigation
    window.currentSetlistContext = { songIds, currentIndex };
}
function showAmbientPad(){ 
    console.log('showAmbientPad called');
    // Show the ambient pad modal
    ambientModal.classList.remove('hidden'); 
    ambientModal.style.display = 'flex'; // Ensure it's visible
    
    // Highlight the currently active pitch if the ambient pad is playing
    if (currentPadPitch && ambientPad && ambientPad.playing) {
        // Remove active class from all pitch buttons
        document.querySelectorAll('#pitch-buttons .pitch-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Add active class to the current pitch button
        const currentPitchBtn = document.querySelector(`#pitch-buttons .pitch-btn[data-pitch="${currentPadPitch}"]`);
        if (currentPitchBtn) {
            currentPitchBtn.classList.add('active');
        }
        
        // Update the mode buttons to reflect the current mode
        document.querySelectorAll('[data-mode]').forEach(btn => {
            btn.classList.remove('active');
        });
        
        const currentModeBtn = document.querySelector(`[data-mode="${currentPadMode}"]`);
        if (currentModeBtn) {
            currentModeBtn.classList.add('active');
        }
    }
}
function hideAmbientPad(){ 
    console.log('hideAmbientPad called');
    // Don't stop the ambient pad when modal is closed
    // Only hide the modal
    ambientModal.classList.add('hidden'); 
    ambientModal.style.display = 'none'; // Ensure it's hidden
}

function showAuthPage() {
    // Hide all other pages
    homeSongsPage?.classList.add('hidden');
    homeSetlistsPage?.classList.add('hidden');
    editSongPage?.classList.add('hidden');
    editSetlistPage?.classList.add('hidden');
    viewSetlistPage?.classList.add('hidden');
    lyricsPage?.classList.add('hidden');
    settingsPage?.classList.add('hidden');
    ambientModal?.classList.add('hidden');
    
    // Show auth page
    document.getElementById('auth-page')?.classList.remove('hidden');
}

function showSettingsPage() {
    // Turn off metronome when exiting lyrics page
    stopMetronome();
    const metronomeBtn = document.getElementById('metronome-toggle');
    if (metronomeBtn && metronomeBtn.classList.contains('active')) {
        metronomeBtn.classList.remove('active');
    }
    
    // Hide all other pages
    homeSongsPage?.classList.add('hidden');
    homeSetlistsPage?.classList.add('hidden');
    editSongPage?.classList.add('hidden');
    editSetlistPage?.classList.add('hidden');
    viewSetlistPage?.classList.add('hidden');
    lyricsPage?.classList.add('hidden');
    ambientModal?.classList.add('hidden');
    // Make sure auth page is hidden
    document.getElementById('auth-page')?.classList.add('hidden');
    
    // Show settings page
    settingsPage.classList.remove('hidden');
}

function clearSetlistContext() {
    currentSetlist = null;
    window.currentSetlistContext = null;
}

function navigateToPrevSong() {
    if (window.currentSetlistContext) {
        const { songIds, currentIndex } = window.currentSetlistContext;
        if (currentIndex > 0) {
            const prevIndex = currentIndex - 1;
            const prevSongId = songIds[prevIndex];
            const prevSong = songs.find(s => s.id === prevSongId);
            if (prevSong) {
                showLyricsPageFromSetlist(prevSong, songIds, prevIndex);
            }
        } else {
            // Already at the first song, fade the button
            const prevBtn = document.getElementById('prev-song-btn');
            prevBtn.style.opacity = '0.5';
            prevBtn.style.pointerEvents = 'none';
        }
    }
}

function navigateToNextSong() {
    if (window.currentSetlistContext) {
        const { songIds, currentIndex } = window.currentSetlistContext;
        if (currentIndex < songIds.length - 1) {
            const nextIndex = currentIndex + 1;
            const nextSongId = songIds[nextIndex];
            const nextSong = songs.find(s => s.id === nextSongId);
            if (nextSong) {
                showLyricsPageFromSetlist(nextSong, songIds, nextIndex);
            }
        } else {
            // Already at the last song, fade the button
            const nextBtn = document.getElementById('next-song-btn');
            nextBtn.style.opacity = '0.5';
            nextBtn.style.pointerEvents = 'none';
        }
    }
}

/* ---------- small utilities ---------- */
function isChordToken(tok) {
    return /^[A-G][#b]?(m|dim|aug|sus|Maj|min|\+|A�)?(\/[A-G][#b]?)?$/.test(tok);
}

/* ---------- rendering lists ---------- */
function renderSongsList(filteredSongs = null) {
    const songsList = document.getElementById('songs-list');
    const songsToRender = filteredSongs || songs;
    songsList.innerHTML = songsToRender.map(song => `
        <div class="song-item" data-id="${song.id}" data-user-id="${song.user_id}">
            <div class="song-title">${song.title}</div>
            <div class="song-details">${song.key} � ${song.bpm} bpm</div>
        </div>
    `).join('');
    
    // Update action buttons after a short delay to allow DOM to render
    setTimeout(updateSongActionButtons, 100);
    
    // Add click handlers to song items after a short delay
    setTimeout(() => {
        document.querySelectorAll('.song-item').forEach(item => {
            // Remove any existing click listeners to prevent duplicates
            if (item._songClickListenerAdded) {
                return;
            }
            
            item._songClickListenerAdded = true;
            
            item.addEventListener('click', function() {
                console.log('Song item clicked');
                // Get the song ID from the data attribute
                const dataId = item.getAttribute('data-id');
                console.log('Raw data-id attribute:', dataId);
                const songId = dataId ? parseInt(dataId) : null;
                console.log('Parsed song ID:', songId);
                // Find the corresponding song in the songs array
                console.log('Songs array:', songs);
                const song = songs.find(s => s.id === songId);
                console.log('Found song:', song);
                // If song exists, show the lyrics page
                if (song) {
                    console.log('Calling showLyricsPage with:', song);
                    showLyricsPage(song);
                } else {
                    console.error('Song not found with ID:', songId, 'or data-id was not set');
                    // As fallback, try to find a song by title if available
                    const titleElement = item.querySelector('.song-title');
                    if (titleElement) {
                        const title = titleElement.textContent;
                        const fallbackSong = songs.find(s => s.title === title);
                        if (fallbackSong) {
                            console.log('Found fallback song by title:', fallbackSong);
                            showLyricsPage(fallbackSong);
                        }
                    }
                }
            });
        });
    }, 50); // Small delay to ensure DOM is ready
}

// Update song action buttons based on ownership
async function updateSongActionButtons() {
  const songItems = document.querySelectorAll('.song-item');
  
  for (const item of songItems) {
    const songId = parseInt(item.getAttribute('data-id'));
    const songUserId = item.getAttribute('data-user-id');
    
    let isOwner = false;
    let isLoggedIn = false;
    
    if (window.db) {
      try {
        const { data: { user }, error } = await window.db.auth.getUser();
        if (!error && user) {
          isLoggedIn = true;
          if (songUserId) {
            isOwner = user.id === songUserId;
          }
        }
      } catch (e) {
        console.error('Error checking auth state:', e);
      }
    }
    
    // Update the UI based on ownership
    const detailsEl = item.querySelector('.song-details');
    if (detailsEl) {
      detailsEl.textContent = detailsEl.textContent.replace(' (Mine)', '').trim();
      if (isOwner) {
        detailsEl.textContent += ' (Mine)';
      }
    }
    
    // Add action buttons based on ownership and login status
    let actionsContainer = item.querySelector('.song-actions');
    if (!actionsContainer) {
      actionsContainer = document.createElement('div');
      actionsContainer.className = 'song-actions';
      item.appendChild(actionsContainer);
    }
    
    // Clear existing buttons
    actionsContainer.innerHTML = '';
    
    // Add buttons based on conditions
    if (isLoggedIn && !isOwner) {
      const duplicateBtn = document.createElement('button');
      duplicateBtn.className = 'btn btn-sm btn-secondary duplicate-song-btn';
      duplicateBtn.textContent = 'Duplicate';
      duplicateBtn.dataset.songId = songId;
      duplicateBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        // Trigger duplicate functionality
        const song = songs.find(s => s.id === songId);
        if (song) {
          // Set up the form with song data to duplicate
          document.getElementById('song-title').value = song.title;
          document.getElementById('song-key').value = song.key;
          document.getElementById('song-bpm').value = song.bpm;
          document.getElementById('song-lyrics').value = song.lyrics;
          
          // Parse key to separate key and mode
          let key = song.key;
          let mode = 'major';
          if (key.endsWith('m')) {
            key = key.substring(0, key.length - 1); // Remove 'm'
            mode = 'minor';
          }
          document.getElementById('song-key').value = key;
          document.getElementById('song-mode').value = mode;
          
          duplicateSong();
        }
      });
      actionsContainer.appendChild(duplicateBtn);
    }
    
    if (isOwner) {
      const editBtn = document.createElement('button');
      editBtn.className = 'btn btn-sm btn-warning edit-song-btn';
      editBtn.textContent = 'Edit';
      editBtn.dataset.songId = songId;
      editBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        const song = songs.find(s => s.id === songId);
        if (song) showEditSongPage(song);
      });
      actionsContainer.appendChild(editBtn);
    }
  }
}

function renderSetlistsList(filteredSetlists = null) {
    const setlistsList = document.getElementById('setlists-list');
    const setlistsToRender = filteredSetlists || setlists;
    setlistsList.innerHTML = setlistsToRender.map(setlist => {
        // Calculate actual song count
        const songCount = setlist.songIds ? setlist.songIds.length : 0;
        
        // Note: We can't determine ownership in the render function due to async nature of auth
        // We'll handle this in the click handler
        const isPlaceholder = true; // Placeholder for template
        
        return `
        <div class="setlist-item" data-id="${setlist.id}" data-user-id="${setlist.user_id}">
            <div class="setlist-title">${setlist.title}</div>
            <div class="setlist-details">${songCount} songs</div>
        </div>`;
    }).join('');
    
    // Add event listeners for setlist items
    const setlistItems = document.querySelectorAll('.setlist-item');
    setlistItems.forEach(item => {
        const setlistId = parseInt(item.getAttribute('data-id'));
        
        // Add click handler for viewing setlist
        item.onclick = async (e) => {
            // Check if the click was on an action button
            if (e.target.classList.contains('duplicate-setlist-btn')) {
                await duplicateSetlist(setlistId);
                return;
            } else if (e.target.classList.contains('edit-setlist-btn')) {
                const setlist = setlists.find(s => s.id === setlistId);
                if (setlist) showEditSetlistPage(setlist);
                return;
            }
            
            // Otherwise, show the setlist
            const setlist = setlists.find(s => s.id === setlistId);
            if (setlist) showViewSetlistPage(setlist);
        };
    });
    
    // Update action buttons after a short delay to allow DOM to render
    setTimeout(updateSetlistActionButtons, 100);
}

/* ---------- ambient UI ---------- */
function renderPitchButtons() {
    const pitches = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const container = document.getElementById('pitch-buttons');
    container.innerHTML = pitches.map(p => `<button class="pitch-btn" data-pitch="${p}">${p}</button>`).join('');
    
    // Add event listeners to the pitch buttons
    document.querySelectorAll('#pitch-buttons .pitch-btn').forEach(button => {
        button.addEventListener('click', function() {
            const pitch = this.getAttribute('data-pitch');
            
            if (ambientPad) {
                // If clicking the same pitch, toggle off
                if (currentPadPitch === pitch) {
                    ambientPad.stop();
                    ambientPad = null;
                    currentPadPitch = null;
                    
                    // Update UI
                    document.querySelectorAll('#pitch-buttons .pitch-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    updatePadStatus('Inactive');
                    return;
                } else {
                    // Different pitch - switch immediately
                    ambientPad.switchToPitch(pitch, currentPadMode);
                }
            } else {
                // No pad currently playing - create new one
                ambientPad = initAmbientPad();
                if (ambientPad) {
                    ambientPad.createPad(pitch, currentPadMode);
                }
            }
            
            // Update the current pitch after creating the pad
            currentPadPitch = pitch;
            
            // Update UI
            document.querySelectorAll('#pitch-buttons .pitch-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            this.classList.add('active');
            
            updatePadStatus('Active: ' + pitch + ' ' + currentPadMode);
        });
    });
}

/* ---------- filters ---------- */
function filterSongs() {
    const searchTerm = document.getElementById('song-search').value.toLowerCase();
    const filteredSongs = songs.filter(song => song.title.toLowerCase().includes(searchTerm));
    renderSongsList(filteredSongs);
    
    // Show/hide clear button
    const clearBtn = document.getElementById('clear-song-search');
    if (searchTerm.length > 0) {
        clearBtn.classList.remove('hidden');
    } else {
        clearBtn.classList.add('hidden');
    }
}
function filterSetlists() {
    const searchTerm = document.getElementById('setlist-search').value.toLowerCase();
    const filteredSetlists = setlists.filter(setlist => setlist.title.toLowerCase().includes(searchTerm));
    renderSetlistsList(filteredSetlists);
    
    // Show/hide clear button
    const clearBtn = document.getElementById('clear-setlist-search');
    if (searchTerm.length > 0) {
        clearBtn.classList.remove('hidden');
    } else {
        clearBtn.classList.add('hidden');
    }
}

function filterAvailableSongs() {
    const searchTerm = document.getElementById('add-song-search').value.toLowerCase();
    const filteredSongs = songs.filter(song => song.title.toLowerCase().includes(searchTerm));
    renderAvailableSongs(filteredSongs);
    
    // Show/hide clear button
    const clearBtn = document.getElementById('clear-add-song-search');
    if (searchTerm.length > 0) {
        clearBtn.classList.remove('hidden');
    } else {
        clearBtn.classList.add('hidden');
    }
}

/* ---------- chord/lyrics parsing & rendering (FIXED) ---------- */

/*
  Approach:
  - parseChordProInline(line): converts a chord-pro inline line into tokens {text, chord?}
  - renderTokenLine(tokens): renders HTML where each word is a .token with chord above
  - renderLyricsWithChords: handles detection of chord-only lines -> attaches to next lyric line
*/

function parseChordProInline(line) {
    // convert \r removed already in caller
    // mark chords with special delimiters then split
    const MARK = '\u0007';
    let s = line.replace(/\[([^\]]+)\]/g, (m, p1) => `${MARK}${p1}${MARK}`);
    // also accept (C) style
    s = s.replace(/\(([^\)]+)\)/g, (m, p1) => `${MARK}${p1}${MARK}`);
    const raw = s.split(/\s+/).filter(Boolean);
    const tokens = [];
    let pendingChord = undefined;
    for (const r of raw) {
        const chordOnly = r.match(/^\u0007(.+)\u0007$/);
        if (chordOnly) {
            pendingChord = chordOnly[1];
            continue;
        }
        // embedded markers
        const embedded = /^(?:\u0007(.+)\u0007)?(.+?)(?:\u0007(.+)\u0007)?$/.exec(r);
        if (embedded) {
            const leftChord = embedded[1];
            const word = embedded[2];
            const rightChord = embedded[3];
            if (leftChord) {
                tokens.push({ text: word, chord: leftChord });
            } else if (pendingChord) {
                tokens.push({ text: word, chord: pendingChord });
                pendingChord = undefined;
            } else {
                tokens.push({ text: word, chord: undefined });
            }
            if (rightChord) pendingChord = rightChord;
        } else {
            tokens.push({ text: r, chord: pendingChord });
            pendingChord = undefined;
        }
    }
    return tokens;
}

function renderTokenLine(tokens) {
    // tokens: [{text, chord?}, ...]
    // Create a container with two rows rendered as inline-block tokens
    // Use min-width in ch units so short words don't collapse and chords keep spacing
    const htmlParts = [];
    htmlParts.push('<div class="token-row" style="line-height: 1;">');
    for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];
        // escape HTML
        const chord = t.chord ? escapeHtml(t.chord) : '&nbsp;';
        // Use fixed width based on text length to ensure consistent spacing
        const width = Math.max(2, t.text.length);
        htmlParts.push(`<span class="token" style="display:inline-block; width:${width}ch; text-align:center; vertical-align:top;"><span class="chord-token" style="display:block; color:#007bff; font-weight:700; margin-bottom:1px; font-size:.9rem;">${chord}</span><span class="word-token" style="display:block; white-space:nowrap; font-family:'Courier New',Courier,monospace; font-size:1rem; color:inherit;">${escapeHtml(t.text)}</span></span>`);
    }
    htmlParts.push('</div>');
    return htmlParts.join('');
}

function escapeHtml(s) {
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function renderLyricsWithChords(lyrics) {
    if (!lyrics) return '';
    // Simply display the lyrics as they are, preserving all formatting
    return escapeHtml(lyrics).replace(/\n/g, '<br>');
}

/* ---------- transpose (unchanged) ---------- */
function transposeSingleChord(chord, noteIndex, notes, steps) {
    const match = chord.match(/^([A-G][#b]?)(.*)$/);
    if (!match) return chord;
    let baseNote = match[1];
    const suffix = match[2] || '';
    // map flats to sharps for consistency
    const flats = { 'Db':'C#','Eb':'D#','Gb':'F#','Ab':'G#','Bb':'A#' };
    if (flats[baseNote]) baseNote = flats[baseNote];
    const currentIndex = noteIndex[baseNote];
    if (currentIndex === undefined) return chord;
    const newIndex = (currentIndex + steps + 12) % 12;
    const newNote = notes[newIndex];
    return newNote + suffix;
}

function transposeLyrics(steps) {
    if (!currentSong) return;
    
    // Update transpose value
    transposeValue += steps;
    // Display with + prefix for positive values
    document.getElementById('transpose-value').textContent = (transposeValue > 0 ? '+' : '') + transposeValue;
    
    const notes = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const noteIndex = {}; notes.forEach((n,i) => noteIndex[n]=i);
    const keyMatch = currentSong.key.match(/^([A-G][#b]?)(.*)$/);
    if (!keyMatch) return;
    const baseNote = keyMatch[1]; const suffix = keyMatch[2] || '';
    const currentIndex = noteIndex[baseNote]; if (currentIndex === undefined) return;
    const newIndex = (currentIndex + steps + 12) % 12; const newNote = notes[newIndex];
    currentSong.key = newNote + suffix;
    document.getElementById('lyrics-details').textContent = `${currentSong.key} � ${currentSong.bpm} bpm`;
    currentSong.lyrics = transposeLyricsContent(currentSong.lyrics, steps, noteIndex, notes);
    document.getElementById('lyrics-content').innerHTML = renderLyricsWithChords(currentSong.lyrics);
    console.log(`Transposed key to ${newNote}${suffix}`);
}

function transposeLyricsContent(lyrics, steps, noteIndex, notes) {
    if (!lyrics) return lyrics;
    return lyrics.split('\n').map(line => {
        if (line.includes('[') && line.includes(']')) {
            return line.replace(/\[([A-G][#b]?(m|dim|aug|sus|Maj|min|\+|A�)?(\/[A-G][#b]?)?)\]/g, (m,chord) => {
                return `[${transposeSingleChord(chord, noteIndex, notes, steps)}]`;
            });
        } else if (line.includes('(') && line.includes(')')) {
            return line.replace(/\(([A-G][#b]?(m|dim|aug|sus|Maj|min|\+|A�)?(\/[A-G][#b]?)?)\)/g, (m,chord) => {
                return `(${transposeSingleChord(chord, noteIndex, notes, steps)})`;
            });
        } else if (/^([A-G][#b]?(m|dim|aug|sus|Maj|min|\+|A�)?(\/[A-G][#b]?)?\s*)+$/.test(line.trim())) {
            return line.replace(/([A-G][#b]?(m|dim|aug|sus|Maj|min|\+|A�)?(\/[A-G][#b]?)?)/g, (m) => transposeSingleChord(m, noteIndex, notes, steps));
        }
        return line;
    }).join('\n');
}



/* ---------- autoscroll ---------- */
let autoscrollInterval = null;

function startAutoscroll(speed) {
    // Clear any existing autoscroll interval
    if (autoscrollInterval) {
        clearInterval(autoscrollInterval);
        autoscrollInterval = null;
    }
    
    // Check if autoscroll is enabled
    const autoscrollToggle = document.getElementById('autoscroll-toggle');
    if (!autoscrollToggle || autoscrollToggle.textContent !== 'On') return;
    
    // Get the scrollable content area
    const scrollableArea = document.querySelector('#lyrics-page .home-content-scrollable');
    if (!scrollableArea) return;
    
    // Calculate scroll speed - slower for lower values
    // Speed 1: extremely slow (0.5 pixels every 100ms)
    // Speed 2: very slow (1 pixel every 100ms)
    // Speed 3: slow (2 pixels every 100ms)
    // Speed 4: medium (4 pixels every 100ms)
    const pixelsPerStep = speed === 1 ? 0.5 : Math.pow(2, speed - 2);
    
    // Start autoscroll interval
    autoscrollInterval = setInterval(() => {
        scrollableArea.scrollBy(0, pixelsPerStep);
        
        // Stop when we reach the bottom
        if (scrollableArea.scrollTop + scrollableArea.clientHeight >= scrollableArea.scrollHeight) {
            clearInterval(autoscrollInterval);
            autoscrollInterval = null;
            // Reset the autoscroll toggle to Off
            if (autoscrollToggle) {
                autoscrollToggle.textContent = 'Off';
                autoscrollToggle.classList.remove('btn-primary');
                autoscrollToggle.classList.add('btn-secondary');
            }
            // Disable the level selector
            const autoscrollLevel = document.getElementById('autoscroll-level');
            if (autoscrollLevel) {
                autoscrollLevel.disabled = true;
            }
        }
    }, 100); // Scroll every 100ms for smooth movement
}

function stopAutoscroll() {
    if (autoscrollInterval) {
        clearInterval(autoscrollInterval);
        autoscrollInterval = null;
    }
}

/* ---------- song CRUD ---------- */
function createNewSong() { showEditSongPage(); }

/* ---------- setlist CRUD ---------- */
// Open the setlist editor to create a new setlist
function createNewSetlist() {
  showEditSetlistPage(null);
}

// Check auth state before allowing to add setlist
async function checkAuthBeforeAddSetlist() {
  try {
    if (window.db) {
      const { data: { user }, error } = await window.db.auth.getUser();
      if (user) {
        // User is logged in, allow adding setlist
        createNewSetlist();
      } else {
        // User is not logged in, show auth page
        showAuthPage();
      }
    } else {
      // DB not initialized, show auth page
      showAuthPage();
    }
  } catch (error) {
    console.error('Error checking auth state:', error);
    showAuthPage();
  }
}

// Show the setlist editor (editing existing setlist or creating new)
function showEditSetlistPage(setlist = null, fromViewSetlist = false) {
  homeSongsPage.classList.add('hidden');
  homeSetlistsPage.classList.add('hidden');
  editSongPage.classList.add('hidden');
  editSetlistPage.classList.remove('hidden');
  viewSetlistPage.classList.add('hidden');
  lyricsPage.classList.add('hidden');
  settingsPage.classList.add('hidden');
  ambientModal.classList.add('hidden');
  cameFromViewSetlist = fromViewSetlist;

  // clear search box for available songs
  const addSearch = document.getElementById('add-song-search');
  if (addSearch) addSearch.value = '';

  if (setlist) {
    // Editing existing setlist
    document.getElementById('edit-setlist-title').textContent = 'Edit Setlist';
    document.getElementById('setlist-title').value = setlist.title;
    editingSetlistId = setlist.id;

    // Render songs in setlist
    renderSetlistSongs(setlist.songIds);

    // Show delete button
    document.getElementById('delete-setlist-btn').style.display = 'block';
  } else {
    // Creating new setlist
    document.getElementById('edit-setlist-title').textContent = 'New Setlist';
    document.getElementById('setlist-title').value = '';
    editingSetlistId = null;

    // Clear songs in setlist
    document.getElementById('setlist-songs-container').innerHTML = '';

    // Hide delete button
    document.getElementById('delete-setlist-btn').style.display = 'none';
  }

  // Render available songs and wire search
  renderAvailableSongs();
}

// Save the setlist to Supabase database (new or existing)
async function saveSetlist() {
  const title = document.getElementById('setlist-title').value.trim();
  if (!title) {
    alert('Please enter a setlist title');
    return;
  }

  // Collect song IDs from the setlist container (in order)
  const songIds = [];
  document.querySelectorAll('.setlist-song-item').forEach(item => {
    const id = parseInt(item.getAttribute('data-song-id'));
    if (!isNaN(id)) songIds.push(id);
  });

  try {
    if (!window.db) {
      throw new Error('Database not initialized');
    }
    
    // Get current user
    const { data: { user }, error: userError } = await window.db.auth.getUser();
    
    if (userError || !user) {
      // If user is not logged in, redirect to auth page
      showAuthPage();
      return;
    }
    
    // Prepare setlist data
    const setlistData = {
      title,
      user_id: user.id  // Include user_id as required
    };
    
    if (editingSetlistId) {
      // Check if user owns this setlist
      const { data: existingSetlist, error: fetchError } = await window.db
        .from('setlists')
        .select('user_id')
        .eq('id', editingSetlistId)
        .single();
        
      if (fetchError) {
        console.error('Error fetching setlist:', fetchError);
        alert('Error accessing setlist: ' + fetchError.message);
        return;
      }
      
      if (existingSetlist.user_id !== user.id) {
        alert('You can only edit your own setlists');
        return;
      }
      
      // Update existing setlist
      const { error } = await window.db
        .from('setlists')
        .update(setlistData)
        .eq('id', editingSetlistId);
      
      if (error) {
        console.error('Error updating setlist:', error);
        alert('Error updating setlist: ' + error.message);
        return;
      }
      
      // Delete existing setlist_songs entries
      const { error: deleteError } = await window.db
        .from('setlist_songs')
        .delete()
        .eq('setlist_id', editingSetlistId);
      
      if (deleteError) {
        console.error('Error clearing setlist songs:', deleteError);
        alert('Error updating setlist songs: ' + deleteError.message);
        return;
      }
      
      // Insert new setlist_songs entries
      if (songIds.length > 0) {
        const setlistSongsData = songIds.map((songId, index) => ({
          setlist_id: editingSetlistId,
          song_id: songId,
          position: index
        }));
        
        const { error: insertSongsError } = await window.db
          .from('setlist_songs')
          .insert(setlistSongsData);
        
        if (insertSongsError) {
          console.error('Error inserting setlist songs:', insertSongsError);
          alert('Error saving setlist songs: ' + insertSongsError.message);
          return;
        }
      }
      
      // Update in local setlists array
      const index = setlists.findIndex(s => s.id === editingSetlistId);
      if (index !== -1) {
        setlists[index] = { id: editingSetlistId, title, songIds, user_id: user.id };
      }
    } else {
      // Insert new setlist
      const { data, error } = await window.db
        .from('setlists')
        .insert([setlistData]);
      
      if (error) {
        console.error('Error inserting setlist:', error);
        alert('Error saving setlist: ' + error.message);
        return;
      }
      
      // Get the newly created setlist ID
      const newSetlistId = data[0].id;
      
      // Insert setlist_songs entries
      if (songIds.length > 0) {
        const setlistSongsData = songIds.map((songId, index) => ({
          setlist_id: newSetlistId,
          song_id: songId,
          position: index
        }));
        
        const { error: insertSongsError } = await window.db
          .from('setlist_songs')
          .insert(setlistSongsData);
        
        if (insertSongsError) {
          console.error('Error inserting setlist songs:', insertSongsError);
          alert('Error saving setlist songs: ' + insertSongsError.message);
          return;
        }
      }
    }
    
    // Re-fetch setlists from database to ensure latest data
    await loadSetlistsFromDatabase();
    
    // Navigate back appropriately
    if (cameFromViewSetlist && editingSetlistId) {
      // Find the updated setlist and show it
      const updatedSetlist = setlists.find(s => s.id === editingSetlistId);
      if (updatedSetlist) {
        showViewSetlistPage(updatedSetlist);
      } else {
        showSetlistsPage();
      }
    } else {
      showSetlistsPage();
    }
  } catch (error) {
    console.error('Error in saveSetlist:', error);
    alert('Error saving setlist: ' + error.message);
  }
}

// Delete setlist (already wired to button)
async function deleteSetlist() {
  if (editingSetlistId && confirm('Are you sure you want to delete this setlist?')) {
    try {
      if (!window.db) {
        throw new Error('Database not initialized');
      }
      
      // Get current user
      const { data: { user }, error: userError } = await window.db.auth.getUser();
      
      if (userError || !user) {
        // If user is not logged in, redirect to auth page
        showAuthPage();
        return;
      }
      
      // Check if user owns this setlist
      const { data: existingSetlist, error: fetchError } = await window.db
        .from('setlists')
        .select('user_id')
        .eq('id', editingSetlistId)
        .single();
        
      if (fetchError) {
        console.error('Error fetching setlist:', fetchError);
        alert('Error accessing setlist: ' + fetchError.message);
        return;
      }
      
      if (existingSetlist.user_id !== user.id) {
        alert('You can only delete your own setlists');
        return;
      }
      
      // Delete from Supabase database
      const { error } = await window.db
        .from('setlists')
        .delete()
        .match({ id: editingSetlistId, user_id: user.id }); // Ensure user owns the setlist
      
      if (error) {
        console.error('Error deleting setlist:', error);
        alert('Error deleting setlist: ' + error.message);
        return;
      }
      
      // Also delete related setlist_songs entries (handled by cascade)
      
      // Re-fetch setlists from database to ensure latest data
      await loadSetlistsFromDatabase();
      
      // Navigate back appropriately
      if (cameFromViewSetlist) {
        showSetlistsPage();
      } else {
        showSetlistsPage();
      }
    } catch (error) {
      console.error('Error in deleteSetlist:', error);
      alert('Error deleting setlist: ' + error.message);
    }
  }
}

// Duplicate setlist functionality
async function duplicateSetlist(setlistId) {
  try {
    if (!window.db) {
      throw new Error('Database not initialized');
    }
    
    // Get current user
    const { data: { user }, error: userError } = await window.db.auth.getUser();
    
    if (userError || !user) {
      // If user is not logged in, redirect to auth page
      showAuthPage();
      return;
    }
    
    // Get the original setlist and its songs
    const { data: originalSetlist, error: setlistError } = await window.db
      .from('setlists')
      .select('*')
      .eq('id', setlistId)
      .single();
    
    if (setlistError) {
      console.error('Error fetching original setlist:', setlistError);
      alert('Error accessing setlist: ' + setlistError.message);
      return;
    }
    
    // Get the original setlist songs
    const { data: originalSetlistSongs, error: songsError } = await window.db
      .from('setlist_songs')
      .select('*')
      .eq('setlist_id', setlistId)
      .order('position', { ascending: true });
    
    if (songsError) {
      console.error('Error fetching original setlist songs:', songsError);
      alert('Error accessing setlist songs: ' + songsError.message);
      return;
    }
    
    // Create a new setlist for the current user
    const newSetlistTitle = originalSetlist.title + ' (Copy)';
    
    const newSetlistData = {
      title: newSetlistTitle,
      user_id: user.id  // Set to current user
    };
    
    // Insert the new setlist
    const { data: newSetlist, error: insertError } = await window.db
      .from('setlists')
      .insert([newSetlistData]);
    
    if (insertError) {
      console.error('Error creating new setlist:', insertError);
      alert('Error duplicating setlist: ' + insertError.message);
      return;
    }
    
    // Get the new setlist ID
    const newSetlistId = newSetlist[0].id;
    
    // Create the setlist_songs entries for the new setlist
    if (originalSetlistSongs.length > 0) {
      const newSetlistSongsData = originalSetlistSongs.map((song, index) => ({
        setlist_id: newSetlistId,
        song_id: song.song_id,
        position: song.position  // Keep original positions
      }));
      
      const { error: insertSongsError } = await window.db
        .from('setlist_songs')
        .insert(newSetlistSongsData);
      
      if (insertSongsError) {
        console.error('Error copying setlist songs:', insertSongsError);
        alert('Error duplicating setlist songs: ' + insertSongsError.message);
        return;
      }
    }
    
    // Re-fetch setlists from database to ensure latest data
    await loadSetlistsFromDatabase();
    
    alert('Setlist duplicated successfully!');
  } catch (error) {
    console.error('Error in duplicateSetlist:', error);
    alert('Error duplicating setlist: ' + error.message);
  }
}

// Update setlist action buttons based on ownership
async function updateSetlistActionButtons() {
  const setlistItems = document.querySelectorAll('.setlist-item');
  
  for (const item of setlistItems) {
    const setlistId = parseInt(item.getAttribute('data-id'));
    const setlistUserId = item.getAttribute('data-user-id');
    
    let isOwner = false;
    let isLoggedIn = false;
    
    if (window.db) {
      try {
        const { data: { user }, error } = await window.db.auth.getUser();
        if (!error && user) {
          isLoggedIn = true;
          if (setlistUserId) {
            isOwner = user.id === setlistUserId;
          }
        }
      } catch (e) {
        console.error('Error checking auth state:', e);
      }
    }
    
    // Update the UI based on ownership
    const detailsEl = item.querySelector('.setlist-details');
    if (detailsEl) {
      detailsEl.textContent = detailsEl.textContent.replace(' (Mine)', '').trim();
      if (isOwner) {
        detailsEl.textContent += ' (Mine)';
      }
    }
    
    // Add action buttons based on ownership and login status
    let actionsContainer = item.querySelector('.setlist-actions');
    if (!actionsContainer) {
      actionsContainer = document.createElement('div');
      actionsContainer.className = 'setlist-actions';
      item.appendChild(actionsContainer);
    }
    
    // Clear existing buttons
    actionsContainer.innerHTML = '';
    
    // Add buttons based on conditions
    if (isLoggedIn && !isOwner) {
      const duplicateBtn = document.createElement('button');
      duplicateBtn.className = 'btn btn-sm btn-secondary duplicate-setlist-btn';
      duplicateBtn.textContent = 'Duplicate';
      duplicateBtn.dataset.setlistId = setlistId;
      actionsContainer.appendChild(duplicateBtn);
    }
    
    if (isOwner) {
      const editBtn = document.createElement('button');
      editBtn.className = 'btn btn-sm btn-warning edit-setlist-btn';
      editBtn.textContent = 'Edit';
      editBtn.dataset.setlistId = setlistId;
      actionsContainer.appendChild(editBtn);
    }
  }
}

/* Render the songs currently in the setlist editor.
   Provides drag handle, up/down, and remove controls.
*/
function renderSetlistSongs(songIds) {
  const container = document.getElementById('setlist-songs-container');
  container.innerHTML = '';
}

function renderViewSetlistSongs(songIds) {
  const container = document.getElementById('view-setlist-songs-container');
  container.innerHTML = '';

  // Build DOM elements in order
  songIds.forEach((songId, index) => {
    const song = songs.find(s => s.id === songId);
    if (!song) return;

    const el = document.createElement('div');
    el.className = 'view-setlist-song-item';
    el.setAttribute('data-song-id', songId);
    el.setAttribute('data-index', index);

    el.innerHTML = `
      <div class="song-title">${escapeHtml(song.title)}</div>
      <div class="song-details">${escapeHtml(song.key)} � ${song.bpm} bpm</div>
    `;

    el.addEventListener('click', () => {
      showLyricsPageFromSetlist(song, songIds, index);
    });

    container.appendChild(el);
  });
}

function renderSetlistSongs(songIds) {
  const container = document.getElementById('setlist-songs-container');
  container.innerHTML = '';

  // Build DOM elements in order
  songIds.forEach((songId, index) => {
    const song = songs.find(s => s.id === songId);
    if (!song) return;

    const el = document.createElement('div');
    el.className = 'setlist-song-item';
    el.setAttribute('data-song-id', songId);
    el.setAttribute('draggable', 'true');

    el.innerHTML = `
      <div class="setlist-song-info" style="display:flex;align-items:center;gap:10px;">
        <span class="drag-handle" title="Drag to reorder" style="cursor:grab;">�~�</span>
        <div style="min-width:0">
          <div class="setlist-song-title">${escapeHtml(song.title)}</div>
          <div class="setlist-song-details">${escapeHtml(song.key)} � ${song.bpm} bpm</div>
        </div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;">
        <button class="remove-song-btn" title="Remove">A-</button>
      </div>
    `;

    // Drag and drop is the primary way to reorder

    // remove handler
    el.querySelector('.remove-song-btn').addEventListener('click', () => {
      el.remove();
      
      // Update the setlist data in localStorage
      const newSongIds = Array.from(container.children).map(ch => parseInt(ch.getAttribute('data-song-id')));
      
      // Update the setlist in the global setlists array
      if (editingSetlistId) {
        const index = setlists.findIndex(s => s.id === editingSetlistId);
        if (index !== -1) {
          setlists[index].songIds = newSongIds;
          // Save to localStorage
          localStorage.setItem('setlistManager_setlists', JSON.stringify(setlists));
        }
      }
      
      // Refresh the available songs list to show the newly removed song
      renderAvailableSongs();
    });

    // Drag and drop handlers
    el.addEventListener('dragstart', (ev) => {
      ev.dataTransfer.setData('text/plain', index.toString());
      el.classList.add('dragging');
    });
    el.addEventListener('dragend', () => {
      el.classList.remove('dragging');
    });

    el.addEventListener('dragover', (ev) => {
      ev.preventDefault();
      el.classList.add('drag-over');
    });
    el.addEventListener('dragleave', () => {
      el.classList.remove('drag-over');
    });
    el.addEventListener('drop', (ev) => {
      ev.preventDefault();
      el.classList.remove('drag-over');
      const fromIndex = parseInt(ev.dataTransfer.getData('text/plain'), 10);
      const children = Array.from(container.children);
      const toIndex = children.indexOf(el);
      if (!isNaN(fromIndex) && toIndex !== -1 && fromIndex !== toIndex) {
        moveSongInSetlist(fromIndex, toIndex);
      }
    });

    container.appendChild(el);
  });
}

/* Move an element in the DOM list representing setlist songs.
   fromIdx and toIdx are indices in the container children list.
*/
function moveSongInSetlist(fromIdx, toIdx) {
  const container = document.getElementById('setlist-songs-container');
  const children = Array.from(container.children);
  if (fromIdx < 0 || toIdx < 0 || fromIdx >= children.length || toIdx >= children.length) return;

  const node = children[fromIdx];
  // remove then re-insert
  if (fromIdx < toIdx) {
    // insert after target
    container.insertBefore(node, children[toIdx].nextSibling);
  } else {
    container.insertBefore(node, children[toIdx]);
  }

  // Re-index up/down button data-idx (optional) - simply re-render to refresh consistent state
  // Build a new songId array and re-render to refresh handlers cleanly
  const newSongIds = Array.from(container.children).map(ch => parseInt(ch.getAttribute('data-song-id')));
  renderSetlistSongs(newSongIds);
  
  // Refresh the available songs list
  renderAvailableSongs();
}

/* Add a song to the setlist editor (prevents duplicates) */
function addSongToSetlist(songId) {
  const container = document.getElementById('setlist-songs-container');
  // prevent duplicates
  if (container.querySelector(`.setlist-song-item[data-song-id="${songId}"]`)) return;
  const song = songs.find(s => s.id === songId);
  if (!song) return;

  // append existing array of song ids then re-render
  const currentIds = Array.from(container.children).map(ch => parseInt(ch.getAttribute('data-song-id')));
  currentIds.push(songId);
  renderSetlistSongs(currentIds);
  
  // Refresh the available songs list to hide the newly added song
  renderAvailableSongs();
}

/* Remove by index in the current setlist editor */
function removeSongFromSetlistIndex(idx) {
  const container = document.getElementById('setlist-songs-container');
  const children = Array.from(container.children);
  if (idx < 0 || idx >= children.length) return;
  children[idx].remove();
  
  // Refresh the available songs list to show the newly removed song
  renderAvailableSongs();
}

/* Render available songs panel (click to add). If filteredSongs provided, use it. */
function renderAvailableSongs(filteredSongs = null) {
  const container = document.getElementById('available-songs-list');
  
  // Get the current setlist song IDs
  let currentSetlistSongIds = [];
  const setlistContainer = document.getElementById('setlist-songs-container');
  if (setlistContainer) {
    currentSetlistSongIds = Array.from(setlistContainer.children).map(ch => parseInt(ch.getAttribute('data-song-id')));
  }
  
  // Filter out songs that are already in the current setlist
  let songsToRender = filteredSongs || songs;
  songsToRender = songsToRender.filter(song => !currentSetlistSongIds.includes(song.id));
  
  container.innerHTML = songsToRender.map(song => `
      <div class="available-song-item" data-song-id="${song.id}">
          <div class="song-title">${escapeHtml(song.title)}</div>
          <div class="song-details">${escapeHtml(song.key)} � ${song.bpm} bpm</div>
      </div>
  `).join('');

  // Add event listeners to add songs (click or double-click)
  document.querySelectorAll('.available-song-item').forEach(item => {
    item.addEventListener('click', () => {
      const songId = parseInt(item.getAttribute('data-song-id'));
      addSongToSetlist(songId);
    });
    // optional: support double-click to add & close
    item.addEventListener('dblclick', () => {
      const songId = parseInt(item.getAttribute('data-song-id'));
      addSongToSetlist(songId);
    });
  });
}

function editSong(song) { 
    window.fromLyricsPage = true;
    showEditSongPage(song); 
}

async function saveSong() {
    const title = document.getElementById('song-title').value;
    const key = document.getElementById('song-key').value;
    const mode = document.getElementById('song-mode').value;
    const bpm = parseInt(document.getElementById('song-bpm').value);
    const timeSig = document.getElementById('song-time-sig').value;
    const lyrics = document.getElementById('song-lyrics').value;
    if (!title) { alert('Please enter a song title'); return; }
    
    // Combine key and mode for display (e.g., "C major" or "Am minor")
    const displayKey = mode === 'minor' ? key + 'm' : key;
    
    try {
        if (!window.db) {
            throw new Error('Database not initialized');
        }
        
        // Get current user
        const { data: { user }, error: userError } = await window.db.auth.getUser();
        
        if (userError || !user) {
            // If user is not logged in, redirect to auth page
            showAuthPage();
            return;
        }
        
        // Prepare song data
        const songData = {
            title,
            key: displayKey,
            bpm: bpm || 120,  // Default to 120 if not provided
            lyrics,
            user_id: user.id  // Include user_id as required
        };
        
        if (editingSongId) {
            // Update existing song
            const { error } = await window.db
                .from('songs')
                .update(songData)
                .eq('id', editingSongId);
            
            if (error) {
                console.error('Error updating song:', error);
                alert('Error updating song: ' + error.message);
                return;
            }
            
            // Update in local songs array
            const index = songs.findIndex(s => s.id === editingSongId);
            if (index !== -1) {
                songs[index] = { ...songs[index], title, key: displayKey, bpm, lyrics };
            }
        } else {
            // Insert new song
            const { data, error } = await window.db
                .from('songs')
                .insert([songData]);
            
            if (error) {
                console.error('Error inserting song:', error);
                alert('Error saving song: ' + error.message);
                return;
            }
        }
        
        // Re-fetch songs from database to ensure latest data
        await loadSongsFromDatabase();
        
        // If we came from the lyrics page, go back to it
        if (window.fromLyricsPage) {
            // Find the saved song in the updated list
            const savedSong = songs.find(s => s.title === title && s.key === displayKey);
            if (savedSong) {
                currentSong = savedSong;
                showLyricsPage(savedSong);
                window.fromLyricsPage = false;
            } else {
                showSongsPage();
            }
        } else {
            showSongsPage();
        }
    } catch (error) {
        console.error('Error in saveSong:', error);
        alert('Error saving song: ' + error.message);
    }
}

async function deleteSong() {
    if (editingSongId && confirm('Are you sure you want to delete this song?')) {
        try {
            if (!window.db) {
                throw new Error('Database not initialized');
            }
            
            // Get current user
            const { data: { user }, error: userError } = await window.db.auth.getUser();
            
            if (userError || !user) {
                // If user is not logged in, redirect to auth page
                showAuthPage();
                return;
            }
            
            // Delete from Supabase database
            const { error } = await window.db
                .from('songs')
                .delete()
                .match({ id: editingSongId, user_id: user.id }); // Ensure user owns the song
            
            if (error) {
                console.error('Error deleting song:', error);
                alert('Error deleting song: ' + error.message);
                return;
            }
            
            // Re-fetch songs from database to ensure latest data
            await loadSongsFromDatabase();
            showSongsPage();
        } catch (error) {
            console.error('Error in deleteSong:', error);
            alert('Error deleting song: ' + error.message);
        }
    }
}

async function duplicateSong() {
    const title = document.getElementById('song-title').value;
    const key = document.getElementById('song-key').value;
    const mode = document.getElementById('song-mode').value;
    const bpm = parseInt(document.getElementById('song-bpm').value);
    const timeSig = document.getElementById('song-time-sig').value;
    const lyrics = document.getElementById('song-lyrics').value;
    if (!title) { alert('Please save the song before duplicating'); return; }
    
    // Combine key and mode for display (e.g., "C major" or "Am minor")
    const displayKey = mode === 'minor' ? key + 'm' : key;
    
    try {
        if (!window.db) {
            throw new Error('Database not initialized');
        }
        
        // Get current user
        const { data: { user }, error: userError } = await window.db.auth.getUser();
        
        if (userError || !user) {
            // If user is not logged in, redirect to auth page
            showAuthPage();
            return;
        }
        
        // Prepare duplicated song data
        const duplicatedSongData = {
            title: title + ' (Copy)',
            key: displayKey,
            bpm: bpm || 120,  // Default to 120 if not provided
            lyrics,
            user_id: user.id  // Include user_id as required
        };
        
        // Insert duplicated song into Supabase
        const { data, error } = await window.db
            .from('songs')
            .insert([duplicatedSongData]);
        
        if (error) {
            console.error('Error duplicating song:', error);
            alert('Error duplicating song: ' + error.message);
            return;
        }
        
        // Re-fetch songs from database to ensure latest data
        await loadSongsFromDatabase();
        alert('Song duplicated successfully!');
    } catch (error) {
        console.error('Error in duplicateSong:', error);
        alert('Error duplicating song: ' + error.message);
    }
}

/* ---------- metronome ---------- */
let audioContext = null;
let nextBeatTime = 0;
let metronomeBeat = 0;
let beatsPerMeasure = 4; // Default to 4/4 time
let isPlaying = false;
let scheduleTimer = null;

function toggleMetronome() {
    const metronomeBtn = document.getElementById('metronome-toggle');
    
    if (metronomeBtn.classList.contains('active')) {
        // Turn off metronome
        stopMetronome();
        metronomeBtn.classList.remove('active');
        console.log('Metronome OFF');
    } else {
        // Turn on metronome
        if (startMetronome()) {
            metronomeBtn.classList.add('active');
            console.log('Metronome ON');
        }
    }
}

function startMetronome() {
    // Need a song to play metronome for
    if (!currentSong) {
        alert('Please select a song first');
        return false;
    }
    
    // Parse time signature
    parseTimeSignature();
    
    // Create audio context if needed
    if (!audioContext) {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.error('Web Audio API is not supported in this browser', e);
            alert('Metronome is not supported in your browser');
            return false;
        }
    }
    
    // Resume audio context if suspended
    if (audioContext.state === 'suspended') {
        audioContext.resume();
    }
    
    // Stop any existing metronome
    stopMetronome();
    
    // Reset beat counter
    metronomeBeat = 0;
    isPlaying = true;
    
    // Set next beat time to now
    nextBeatTime = audioContext.currentTime;
    
    // Start scheduling
    scheduleBeats();
    
    return true;
}

function stopMetronome() {
    isPlaying = false;
    metronomeBeat = 0;
    if (scheduleTimer) {
        clearTimeout(scheduleTimer);
        scheduleTimer = null;
    }
}

function parseTimeSignature() {
    if (!currentSong || !currentSong.timeSig) {
        beatsPerMeasure = 4;
        return;
    }
    
    // Parse time signature like "4/4", "3/4", "6/8"
    const parts = currentSong.timeSig.split('/');
    if (parts.length === 2 && !isNaN(parts[0])) {
        beatsPerMeasure = parseInt(parts[0]);
    } else {
        beatsPerMeasure = 4; // Default fallback
    }
}

function scheduleBeats() {
    if (!isPlaying || !audioContext) return;
    
    const bpm = currentSong.bpm || 120;
    const beatInterval = 60.0 / bpm; // Time between beats in seconds
    
    // Schedule beats 100-200ms in advance
    const currentTime = audioContext.currentTime;
    const scheduleAheadTime = 0.2; // 200ms lookahead
    
    // Schedule beats until we've filled the lookahead window
    while (nextBeatTime < currentTime + scheduleAheadTime) {
        scheduleClick(nextBeatTime, metronomeBeat);
        
        // Advance to next beat
        nextBeatTime += beatInterval;
        metronomeBeat = (metronomeBeat + 1) % beatsPerMeasure;
    }
    
    // Schedule the next batch
    scheduleTimer = setTimeout(scheduleBeats, 50); // Check every 50ms
}

function scheduleClick(beatTime, beatNumber) {
    // Create the click sound to be played at the scheduled time
    createClickSound(beatTime, beatNumber);
}

function createClickSound(beatTime, beatNumber) {
    if (!audioContext) return;
    
    // Load and play the metronome sound file
    if (!metronomeBuffer) {
        console.warn('Metronome sound not loaded yet');
        // Try to create a fallback sound
        createFallbackClick(beatTime, beatNumber);
        return;
    }
    
    // Create audio nodes
    const source = audioContext.createBufferSource();
    source.buffer = metronomeBuffer;
    
    const gainNode = audioContext.createGain();
    
    // All beats sound the same with adjustable volume
    const volume = metronomeVolume / 100 * 0.8; // Scale to 0-0.8 range
    gainNode.gain.setValueAtTime(volume, beatTime);
    
    // Connect nodes: source -> gain -> destination
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Play the metronome sound at the scheduled time
    source.start(beatTime);
}

function createFallbackClick(beatTime, beatNumber) {
    // Create a simple click sound as fallback
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    // All beats sound the same with adjustable volume
    oscillator.frequency.setValueAtTime(880, beatTime);
    const volume = metronomeVolume / 100 * 0.5; // Scale to 0-0.5 range
    gainNode.gain.setValueAtTime(volume, beatTime);
    
    // Quick decay
    gainNode.gain.exponentialRampToValueAtTime(0.001, beatTime + 0.05);
    
    // Connect and play
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.start(beatTime);
    oscillator.stop(beatTime + 0.05);
}
</script>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
// Initialize Supabase client when the library is loaded
function initSupabase() {
  // Initialize Supabase client - REPLACE WITH YOUR SUPABASE PROJECT DETAILS
  const supabaseUrl = 'https://xkrluahogjgnzusaqipl.supabase.co';
  const supabaseKey = 'sb_publishable_XktEPytQmGvio4gDIv88pQ_tkBm7JbZ';
  window.db = window.supabase.createClient(supabaseUrl, supabaseKey);

  // Auth functionality
  const status = document.getElementById("status");
  const userInfo = document.getElementById("user-info");
  const userEmailSpan = document.getElementById("user-email");
  const logoutBtn = document.getElementById("logout");
  const loginForm = document.getElementById("login-form");

  // Check initial auth state
  window.db.auth.onAuthStateChange((event, session) => {
    updateAuthUI(session?.user);
  });

  // Initial check for current user
  window.db.auth.getSession().then(({ data: { session } }) => {
    updateAuthUI(session?.user);
  });

// Update UI based on auth state
  function updateAuthUI(user) {
    if (user) {
      // User is logged in
      document.getElementById("email").value = user.email || '';
      document.getElementById("password").value = '';
      
      userEmailSpan.textContent = user.email;
      userInfo.style.display = "block";
      loginForm.style.display = "none";
      logoutBtn.style.display = "block";
      
      // Show Add Song button
      const addSongBtn = document.getElementById('add-song-btn');
      if (addSongBtn) addSongBtn.style.display = "block";
      
      status.textContent = `? Logged in as ${user.email}`;
      status.style.display = "block";
    } else {
      // User is not logged in
      userInfo.style.display = "none";
      loginForm.style.display = "block";
      logoutBtn.style.display = "none";
      
      // Hide Add Song button
      const addSongBtn = document.getElementById('add-song-btn');
      if (addSongBtn) addSongBtn.style.display = "none";
      
      status.textContent = "Please log in";
      status.style.display = "none";
    }
  }

  // Auth logout button functionality
  const authLogoutBtn = document.getElementById("auth-logout");
  if (authLogoutBtn) {
    authLogoutBtn.addEventListener("click", async () => {
      if (window.db) {
        await window.db.auth.signOut();
      }
      status.textContent = "?? Logged out";
      status.style.display = "block";
      
      // Update UI to show login form
      userInfo.style.display = "none";
      loginForm.style.display = "block";
      logoutBtn.style.display = "none";
      
      // Clear inputs
      document.getElementById("email").value = '';
      document.getElementById("password").value = '';
    });
  }

  // Sign up functionality
  document.getElementById("signup").onclick = async () => {
    const email = document.getElementById("email").value;
    const password = document.getElementById("password").value;

    if (!email || !password) {
      status.textContent = "�?O Please enter both email and password";
      status.style.display = "block";
      return;
    }

    const { error } = await window.db.auth.signUp({
      email,
      password
    });

    status.textContent = error
      ? "? " + error.message
      : "? Signup successful (check email if required)";
    status.style.display = "block";
  };

  // Login functionality
  document.getElementById("login").onclick = async () => {
    const email = document.getElementById("email").value;
    const password = document.getElementById("password").value;

    if (!email || !password) {
      status.textContent = "�?O Please enter both email and password";
      status.style.display = "block";
      return;
    }

    const { data, error } = await window.db.auth.signInWithPassword({
      email,
      password
    });

    status.textContent = error
      ? "? " + error.message
      : "? Logged in as " + data.user.email;
    status.style.display = "block";
  };

  // Logout functionality
  document.getElementById("logout").onclick = async () => {
    await window.db.auth.signOut();
    status.textContent = "?? Logged out";
    status.style.display = "block";
  };

  // Back button from auth page
  document.getElementById("back-to-songs-from-auth").onclick = function() {
    showSongsPage();
  };

  // Load both songs and setlists after initialization
  setTimeout(async () => {
    if (window.db) {
      await loadSongsFromDatabase();
      await loadSetlistsFromDatabase();
      
      // Also load user preferences if needed
      loadUserPreferences();
      
      // Update action buttons after data is loaded
      setTimeout(() => {
        updateSongActionButtons();
        updateSetlistActionButtons();
      }, 500);
    } else {
      console.error('Supabase client not initialized');
    }
  }, 100);
}

  // Auth menu item functionality (for the three-dot menu Account option)
    document.getElementById("auth-menu-item")?.addEventListener('click', async (e) => {
      e.stopPropagation();
      showAuthPage();
    });

  // Initialize Supabase when everything is loaded
  if (window.supabase) {
    initSupabase();
  } else {
    // If Supabase hasn't loaded yet, wait for it
    document.addEventListener('DOMContentLoaded', function() {
      if (window.supabase) {
        initSupabase();
      } else {
        // Try again after a brief delay
        setTimeout(function() {
          if (window.supabase) {
            initSupabase();
          }
        }, 1000);
      }
    });
  }

// Add click handlers for the account menu items
// Using a more robust approach to ensure elements are available
function attachAccountMenuHandlers() {
  // Account menu item for songs page
  const accountMenuItemSongs = document.getElementById('account-menu-item-songs');
  if (accountMenuItemSongs) {
    accountMenuItemSongs.removeEventListener('click', accountMenuItemSongs.clickHandler || null);
    accountMenuItemSongs.clickHandler = function(e) {
      e.stopPropagation();
      // Close the menu
      const dropdown = this.closest('.dropdown-menu');
      if (dropdown) {
        dropdown.classList.add('hidden');
      }
      // Show auth page
      if (typeof showAuthPage === 'function') {
        showAuthPage();
      }
    };
    accountMenuItemSongs.addEventListener('click', accountMenuItemSongs.clickHandler);
    console.log('Attached click handler to songs account menu item');
  } else {
    console.log('Songs account menu item not found');
  }
  
  // Account menu item for setlists page
  const accountMenuItemSetlists = document.getElementById('account-menu-item-setlists');
  if (accountMenuItemSetlists) {
    accountMenuItemSetlists.removeEventListener('click', accountMenuItemSetlists.clickHandler || null);
    accountMenuItemSetlists.clickHandler = function(e) {
      e.stopPropagation();
      // Close the menu
      const dropdown = this.closest('.dropdown-menu');
      if (dropdown) {
        dropdown.classList.add('hidden');
      }
      // Show auth page
      if (typeof showAuthPage === 'function') {
        showAuthPage();
      }
    };
    accountMenuItemSetlists.addEventListener('click', accountMenuItemSetlists.clickHandler);
    console.log('Attached click handler to setlists account menu item');
  } else {
    console.log('Setlists account menu item not found');
  }
}

// Attach handlers when DOM is loaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', function() {
    attachAccountMenuHandlers();
    // Ensure the handlers are also attached after a short delay in case of timing issues
    setTimeout(attachAccountMenuHandlers, 100);
  });
} else {
  // DOM is already loaded, try attaching immediately
  attachAccountMenuHandlers();
  // Ensure the handlers are also attached after a short delay in case of timing issues
  setTimeout(attachAccountMenuHandlers, 100);
}

// As an additional fallback, use event delegation on the dropdown menus
// This ensures clicks on account menu items are captured even if direct handlers fail
document.addEventListener('click', function(e) {
  if (e.target && (e.target.id === 'account-menu-item-songs' || e.target.id === 'account-menu-item-setlists')) {
    e.stopPropagation();
    // Close the menu
    const dropdown = e.target.closest('.dropdown-menu');
    if (dropdown) {
      dropdown.classList.add('hidden');
    }
    // Show auth page
    if (typeof showAuthPage === 'function') {
      showAuthPage();
    } else {
      console.error('showAuthPage function not found');
    }
  }
});
</script>

<script>
// Force unregister old service workers to clear cache
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then(function(registrations) {
    for(let registration of registrations) {
      registration.unregister();
    }
  });
}

// Register service worker if supported
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('./service-worker.js')
      .then(function(registration) {
        console.log('ServiceWorker registration successful with scope: ', registration.scope);
      })
      .catch(function(error) {
        console.log('ServiceWorker registration failed: ', error);
      });
  });
}
</script>
<script src="main.js"></script>
<script src="setlists.js"></script>
<script src="auth.js"></script>
<script src="utils.js"></script>
</body>
</html>
